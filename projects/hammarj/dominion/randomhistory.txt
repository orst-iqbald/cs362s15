I decided to start by creating a random gameState generator called genRandState().  It assigns a random but valid value to every variable in struct gameState. I chose to stick with only valid values because the gameState is only modified internally by the game code and so doesn't span any trust boundaries. Whether this assumption is truly merited or not, it is the philosophy of all the dominion code I've seen so far. So, feeding this code invalid values isn't going to produce bugs that the developers would care about. Generated values are evenly distributed along the range of valid values. These ranges not only respect the sizes of the various arrays, but they are also consistent with the rules of the game and other gameState variables that they depend on.  So numPlayers has a range of [0,3] and the range of i in playedCards[i] is dependent on playedCardCount. One of the big things that isn't valid about the gameStates generated with this function is that the supply is not limited to having exactly 10 Kingdom cards. I set every variable for completeness even though the variables concerning the embargo and outposts card won't play a role in the random tests I'm going to perform (but hey, who knows, maybe they will. Practicing that paranoia...).

I then created a function called insertCardRand() that inserts a given card into a random hand position of the current player's hand. I use this to make sure that the player has a particular card so that they can play it in the test.

After that, writing the randomtestcard test was pretty easy.  I just used memcpy() to make a copy of the randomly generated gameState and then compared them after executing the card function.

After sorting out a few bugs in my test code (I need to test my test code...), I ran the random tester on the Smithy card and got perfect coverage! But of course, it's impossible to *not* get perfect coverage because there's nothing variable about the card period. Perfect example of how great coverage does not guarantee good testing. 

However, I did realize that my random generation of gameStates needs work. For instance, the number of cards can range from 0 to 499, but having more than 10 or so cards in your hand is pretty rare. And right now, that's mostly what's getting tested. Having 0 cards or 1 card are important edge cases and they are mostly getting overlooked.

To remedy this, I created a new function called weightedRand(). It allows you to apply weights to ranges of numbers, so that you can have it return a random number between 0 and 9 95% of the time and a random number between 10 and 100 5% of the time. I then used this inside of my genRandState() function.

My oracle for randomtestadventurer.c checks four things.  1) The cumulative change in the number of cards in the deck/discard/hand. 2) The change in the number of cards in the hand. 3) The change in the number of cards in the played card pile. 4) the change in the number of treasure cards in the hand.  If a test set fails, I print the test set number followed by symbols designate the particular tests that failed in that set.

And for coverage, it manages to hit every statement and every branch. I noticed something interesting in the coverage stats. The statement "drawntreasure++;" was executed 3000 times. Since the card is only supposed to draw a maximum of 2 treasures when played, you'd expect this statement to only be executed no more than 2000 times. That tells me that the condition that controls the loops is not right (and this is in fact the case). So coverage stats can even lead you straight to a bug if you know what to look for.

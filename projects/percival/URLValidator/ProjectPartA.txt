CS362 Group Project Part A
--------------------------
Chris McGehee: mcgeheec@onid.oregonstate.edu
Lisa Percival: percival@onid.oregonstate.edu
James Tomlinson: tomlinja@onid.oregonstate.edu


Explain testIsValid() function
------------------------------
The purpose of the testIsValid() function is to verify that the URL Validator’s isValid() function works as intended, namely that it is able to correctly decide whether or not a given URL is valid. There are actually two testIsValid() functions, but the first one (line 43) simply passes the desired parameters to the second one (line 85), which does the real work.

The function exhaustively tests all possible combinations of the URL parts provided, which are intended to generate a representative sample of the input space of possible URLs that could be given to the isValid() function. It includes both valid and input inputs, with many of the invalid inputs being realistic mutations of valid ones. It also includes some edge cases and special cases like empty parts. More details about how the URLs are built can be found elsewhere in this document.

The two special preliminary URL checks at the beginning of the function (line 87 and 88) rely on the assertTrue function to show they’re valid. For the remainder of the URLs, generated by combining parts, the process is a bit more complex. While building the URL, the expected return value of isValid() is set to either true or false, depending on the parts involved. It will be true only if all the parts are valid. Then isValid() is called on the assembled URL, and if it returns true the URL is printed. Then, the actual return value is compared to the expected return value to decide whether the test passed. Assuming printing is enabled, it prints a dot for each passed test and an ‘X’ for each failed one.


How many URLs it is testing
---------------------------
The function tests 31922 URLs. Two of these are the initial straightforward tests of http://www.google.com and http://www.google.com/ on lines 87 and 88. The other 31920 are generated by the combinations of URL parts described in the next section, as part of the do-while loop.

Our initial calculations expected it to test 35910 URLs in the do-while loop, based on the number of possible combinations of URL parts. However, when we counted how many were actually tested the number was 31920, and we realized it is because there is a bug in the incrementTestPartsIndex() function. Line 286 sets maxIndex to the bitwise and of itself and whether the index is the last index for that part. The bug is an off-by-one error and is tricky to explain, so we will illustrate it with an example.

Consider a testPartsIndex array of {7, 18, 6, 9, 2}.
Let the maximum size of each part be {9, 19, 7, 10, 3}.
Note that the check involves part.length - 1, so the maximum index for each is {8, 18, 6, 9, 2}.
Also note that, since every element after the first is already at the maximum index, they will each be set to 0 in the array, but the index variable will remain at the previous value for that iteration of the for loop. This is not true for the first element - the index will be incremented and that new value will be stored as the first element (in this case 7++ == 8).

The for loop starts at the last index and works its way forward, so the first check is 2 == 2, the second 9 == 9, and so forth. Here are the maxIndex calculations in order of completion:
1. The array is now {7, 18, 6, 9, 0}, 2 == 2 is true, and maxIndex is true
2. The array is now {7, 18, 6, 0, 0}, 9 == 9 is true, and maxIndex is true
3. The array is now {7, 18, 0, 0 0}, 6 == 6 is true, and maxIndex is true
4. The array is now {7, 0, 0, 0, 0}, 18 == 18 is true, and maxIndex is true
5. The array is now {8, 0, 0, 0, 0}, 8 == 8 is true, and maxIndex is true

Observe that even though there is still an entire permutation left to consider, maxIndex is true and the function returns false (!maxIndex).

To fix: Increment the index variable when you set a testPartsIndex element to 0 as well, and compare the index to part.length instead of part.length - 1.

It is unclear whether this permutation has been omitted on purpose, as including it results in failed tests. The tests expect the URL www.google.com to be valid, but the URLValidator claims it is not valid. The tests specifically test the URL with an empty scheme.


How it is building the URLs
---------------------------
URLs are built from combinations of URL parts that are either valid or invalid. There are five types of parts: scheme (e.g. http://), authority (e.g. www.google.com), port (e.g. :80), path (e.g. /test1), and query (e.g. ?action=view). Each type of part has a number of different test values associated with a true or false value, where true means it is a valid part and false means it is invalid.

All combinations are created and tested iteratively from the last part through to the first part, i.e. each URL is tested with the different queries, then the path is changed and tested with the different queries, then the port is changed and tested with the different path and query combinations, and so on. To do this, a set of indices start at {0, 0, 0, 0, 0} and are incremented in reverse until the maximum length of that part is reached. Then that part starts from zero again and the next-to-last is incremented by one. For example, the next few iterations would be {0, 0, 0, 0, 1}, {0, 0, 0, 0, 2}, {0, 0, 0, 1, 0}, {0, 0, 0, 1, 1}, etc. The index set is in the form {scheme, authority, port, path, query}.

Each URL is created from the current set of indices using a StringBuffer, so the URL would be made from the parts listed in Index[0] + Index[1] + Index[2] + Index[3] + Index[4]. Whether or not the URL is expected to be valid is determined from the associated true/false value with each part. The values are bitwise anded together, so all must be true for the URL to be valid - if any part is invalid, the entire URL is invalid.

After each URL the index set is incremented as described above. Note that there is currently a bug in the test code that prevents the final scheme from being combined with the remaining parts. This bug is described elsewhere in this document.


Example of valid URL being tested
---------------------------------
http://www.google.com:80/test1?action=edit&mode=up


Example of invalid URL being tested
-----------------------------------
http://www.google.com:80/test1//file


Differences of this real-world test from our unit and card tests
----------------------------------------------------------------
This test is different from our Dominion card game tests for several reasons. The first reason is that the URL validator is much more complex. It contains code in five different files with multiple classes whereas the Dominion game was contained in just one file. Another, more conceptual, difference is that the Dominion tests check the state after a function was called and the URL validator checks the return value of a function. In the Dominion tests, we wrote our tests from scratch. The URL validator, on the other hand, implements a testing framework, JUnit. These differences highlight the fact that the URL validator is a real-world entity and our Dominion tests are not.
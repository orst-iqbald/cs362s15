/*******************************************************************************
- Taylor Jenkins
- jenkitay@onid.oregonstate.edu
- CS 362 - Software Engineering II
- Assignment 3
- filename: coverage1.txt
- Description: A report on the coverage attained by my unit tests, as reported 
-     by gcov.
*******************************************************************************/

*********************************************************
******************                     ******************
******************  gcov -b unittest1  ******************
******************                     ******************
*********************************************************
 
File 'unittest1.c'
Lines executed:48.72% of 39
Branches executed:100.00% of 20
Taken at least once:60.00% of 20
Calls executed:50.00% of 16
unittest1.c:creating 'unittest1.c.gcov'

The coverage is good for this unit test file, since all branches were executed,
and about half of the lines executed, and branches taken at least once. This is
as expected, since all tests passed, and each test has only two choice, pass or 
fail. these unit tests are not particularly severe, though, focusing primarily
on expected functionality and input. More severe testing should be done to gain
confidence.


*********************************************************
******************                     ******************
******************  gcov -b unittest2  ******************
******************                     ******************
*********************************************************
 
File 'unittest2.c'
Lines executed:81.08% of 37
Branches executed:100.00% of 34
Taken at least once:73.53% of 34
Calls executed:66.67% of 9
unittest2.c:creating 'unittest2.c.gcov'

This shows pretty high coverage, with all branches executing, with about 3/4 of 
them taken at least once, and 81% of lines executes. Not shown in this coverage 
data is the coverage that occured while manually analyzing the code to write tests.
I discovered that the kingdomCards function for which this test was written 
is not called by any function in the project.
 
*********************************************************
******************                     ******************
******************  gcov -b unittest3  ******************
******************                     ******************
*********************************************************
 
File 'unittest3.c'
Lines executed:76.40% of 89
Branches executed:100.00% of 48
Taken at least once:85.42% of 48
Calls executed:53.33% of 15
unittest3.c:creating 'unittest3.c.gcov'

Similar to the previous tests, my unit tests for this function are very binary, 
so while branches can be fully executed resulting in 100%, coverage, the results
are either pass or fail. This test tested the discardCard() function, and 
discovered a bug that allows the game play to manipulate out of range elements.

 
*********************************************************
******************                     ******************
******************  gcov -b unittest4  ******************
******************                     ******************
*********************************************************
 
File 'unittest4.c'
Lines executed:52.00% of 125
Branches executed:100.00% of 44
Taken at least once:65.91% of 44
Calls executed:22.50% of 40
unittest4.c:creating 'unittest4.c.gcov'

 
*********************************************************
******************                     ******************
******************  gcov -b cardtest1  ******************
******************                     ******************
*********************************************************
 
File 'cardtest1.c'
Lines executed:96.72% of 61
Branches executed:100.00% of 18
Taken at least once:66.67% of 18
Calls executed:89.47% of 19
cardtest1.c:creating 'cardtest1.c.gcov'

 
*********************************************************
******************                     ******************
******************  gcov -b cardtest2  ******************
******************                     ******************
*********************************************************
 
File 'cardtest2.c'
Lines executed:91.46% of 82
Branches executed:100.00% of 28
Taken at least once:67.86% of 28
Calls executed:80.00% of 25
cardtest2.c:creating 'cardtest2.c.gcov'

 
*********************************************************
******************                     ******************
******************  gcov -b cardtest3  ******************
******************                     ******************
*********************************************************
 
File 'cardtest3.c'
Lines executed:94.78% of 115
Branches executed:100.00% of 38
Taken at least once:76.32% of 38
Calls executed:87.10% of 31
cardtest3.c:creating 'cardtest3.c.gcov'

 
*********************************************************
******************                     ******************
******************  gcov -b cardtest4  ******************
******************                     ******************
*********************************************************
 
File 'cardtest4.c'
Lines executed:67.50% of 80
Branches executed:100.00% of 24
Taken at least once:66.67% of 24
Calls executed:30.00% of 20
cardtest4.c:creating 'cardtest4.c.gcov'

 
*********************************************************
******************                     ******************
******************  gcov -b dominion.c ******************
******************                     ******************
*********************************************************
 
File 'dominion.c'
Lines executed:33.16% of 582
Branches executed:33.81% of 417
Taken at least once:25.90% of 417
Calls executed:14.14% of 99
dominion.c:creating 'dominion.c.gcov'

 
*********************************************************
******************                     ******************
******************   gcov -b rngs.c    ******************
******************                     ******************
*********************************************************
 
File 'rngs.c'
Lines executed:57.38% of 61
Branches executed:50.00% of 32
Taken at least once:37.50% of 32
Calls executed:18.75% of 16
rngs.c:creating 'rngs.c.gcov'

 
*********************************************************
******************                     ******************
******************   unittest1.c.gcov  ******************
******************                     ******************
*********************************************************
 
        -:    0:Source:unittest1.c
        -:    0:Graph:unittest1.gcno
        -:    0:Data:unittest1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*******************************************************************************
        -:    2:- Taylor Jenkins
        -:    3:- jenkitay@onid.oregonstate.edu
        -:    4:- CS 362 - Software Engineering II
        -:    5:- Assignment 3
        -:    6:- filename: unittest1.c
        -:    7:- Description: A unit test of the getCost() function in dominion.c.
        -:    8:- Compile instruction: 
        -:    9:gcc -g -Wall -std=c99 -fpic -coverage -lm unittest1.c dominion.o rngs.o -o unittest1
        -:   10:*******************************************************************************/
        -:   11:
        -:   12:#include <stdlib.h>
        -:   13:#include <string.h>
        -:   14:#include <stdio.h>
        -:   15:#include <math.h>
        -:   16:#include <assert.h>
        -:   17:#include <limits.h>
        -:   18:
        -:   19:#include "dominion.h"
        -:   20:#include "dominion_helpers.h"
        -:   21:#include "rngs.h"
        -:   22:#include "interface.h"
        -:   23:
        -:   24:#define DEBUG 0
        -:   25:#define NOISY_TEST 1
        -:   26:
function main called 1 returned 100% blocks executed 73%
        1:   27:int main(int argc, char *argv[])
        -:   28:{	
        -:   29:   int testCostArray[][2] = { // Reference data for card costs
        -:   30:      {curse, CURSE_COST}, // Card 0
        -:   31:      {estate, ESTATE_COST}, 
        -:   32:      {duchy, DUCHY_COST}, 
        -:   33:      {province, PROVINCE_COST}, 
        -:   34:      {copper, COPPER_COST}, 
        -:   35:      {silver, SILVER_COST}, 
        -:   36:      {gold, GOLD_COST}, 
        -:   37:      {adventurer, ADVENTURER_COST}, 
        -:   38:      {council_room, COUNCIL_ROOM_COST}, 
        -:   39:      {feast, FEAST_COST}, 
        -:   40:      {gardens, GARDEN_COST}, 
        -:   41:      {mine, MINE_COST}, 
        -:   42:      // {moneylender, MONEYLENDER_COST} // 4  -  Not implemented 
        -:   43:      {remodel, REMODEL_COST}, 
        -:   44:      {smithy, SMITHY_COST}, 
        -:   45:      {village, VILLAGE_COST}, 
        -:   46:      // {woodcutter, WOODCUTTER_COST} // 3  -  Not implemented 
        -:   47:      {baron, BARON_COST}, 
        -:   48:      {great_hall, GREAT_HALL_COST}, 
        -:   49:      {minion, MINION_COST}, 
        -:   50:      // {shanty_town, SHANTY_TOWN_COST} // 3  -  Not implemented 
        -:   51:      {steward, STEWARD_COST}, 
        -:   52:      {tribute, TRIBUTE_COST}, 
        -:   53:      // {wishing_well, WISHING_WELL_COST} // 3  -  Not implemented 
        -:   54:      {ambassador, AMBASSADOR_COST}, 
        -:   55:      {cutpurse, CUTPURSE_COST}, 
        -:   56:      {embargo, EMBARGO_COST}, 
        -:   57:      {outpost, OUTPOST_COST}, 
        -:   58:      {salvager, SALVAGER_COST}, 
        -:   59:      {sea_hag, SEA_HAG_COST}, 
        1:   60:      {treasure_map, TREASURE_MAP_COST}}; // Card 27
        -:   61:   
        1:   62:   int s = (sizeof(testCostArray)/sizeof(int))/(sizeof(*testCostArray)/sizeof(int));
        1:   63:   int fail = 0;
        1:   64:   int failcount = 0;
        -:   65:   
        -:   66:   // printf("Province card is 3 (value is: %d)\n", province);
        -:   67:   // printf("The size of the array is %d (should be 27)\n", s);
       28:   68:   for (int i = 0; i < s; i++) {
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
       27:   69:      assert(i == testCostArray[i][0]);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   70:   }
        -:   71:   #if (NOISY_TEST == 1)
        1:   72:      printf("All card names in testCostArray[i][0] match enum CARD in dominion.h.\n");
call    0 returned 100%
        -:   73:   #endif
        -:   74:   // Test expected range of inputs
       28:   75:   for (int i = 0; i < s; i++) {
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
       27:   76:      int c = getCost(i);
call    0 returned 100%
       27:   77:      if (c != testCostArray[i][1]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   78:         fail = 1;
    #####:   79:         failcount++;
    #####:   80:         printf("FAILED: Cost for card %d returned:%d  Expected: %d.\n", 
call    0 never executed
        -:   81:            i, c, testCostArray[i][1]);
        -:   82:      }
        -:   83:   }
        -:   84:   // Test out of range inputs
        1:   85:   if (getCost(s) != -1) { // large values
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   86:      fail = 1;
    #####:   87:      failcount++;
    #####:   88:      printf("FAILED: getCost failed with input of %d.", s);
call    0 never executed
        -:   89:   }
        1:   90:   if (getCost(-1) != -1) { // negative values
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   91:      fail = 1;
    #####:   92:      failcount++;
    #####:   93:      printf("FAILED: getCost failed with input of -1.");
call    0 never executed
        -:   94:   }
        1:   95:   if (getCost('a') != -1) { // character input
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   96:      fail = 1;
    #####:   97:      failcount++;
    #####:   98:      printf("FAILED: getCost failed with input of 'a'.");
call    0 never executed
        -:   99:   }
        1:  100:   if (getCost(INT_MAX) != -1) { // INT_MAX input value
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  101:      fail = 1;
    #####:  102:      failcount++;
    #####:  103:      printf("FAILED: getCost failed with input of INT_MAX.");
call    0 never executed
        -:  104:   }
        1:  105:   if (getCost(INT_MIN) != -1) { // INT_MIN input value
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  106:      fail = 1;
    #####:  107:      failcount++;
    #####:  108:      printf("FAILED: getCost failed with input of INT_MIN.");
call    0 never executed
        -:  109:   }
        -:  110:   // Tests Complete
        1:  111:   if (fail) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  112:      printf("%d getCost tests FAILED\n", failcount);
call    0 never executed
    #####:  113:      return -1;
        -:  114:   }
        -:  115:   #if (NOISY_TEST == 1)
        1:  116:      printf("All getCost tests PASSED\n");
call    0 returned 100%
        -:  117:   #endif
        1:  118:   return 0;
        -:  119:} 
*********************************************************
******************                     ******************
******************   unittest2.c.gcov  ******************
******************                     ******************
*********************************************************
 
        -:    0:Source:unittest2.c
        -:    0:Graph:unittest2.gcno
        -:    0:Data:unittest2.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*******************************************************************************
        -:    2:- Taylor Jenkins
        -:    3:- jenkitay@onid.oregonstate.edu
        -:    4:- CS 362 - Software Engineering II
        -:    5:- Assignment 3
        -:    6:- filename: unittest2.c
        -:    7:- Description: A unit test of the kingdomCards() function in dominion.c.
        -:    8:- Compile instruction: 
        -:    9:gcc -g -Wall -std=c99 -fpic -coverage -lm unittest2.c dominion.o rngs.o -o unittest2
        -:   10:*******************************************************************************/
        -:   11:
        -:   12:#include <stdlib.h>
        -:   13:#include <string.h>
        -:   14:#include <stdio.h>
        -:   15:#include <math.h>
        -:   16:#include <assert.h>
        -:   17:#include <limits.h>
        -:   18:
        -:   19:#include "dominion.h"
        -:   20:#include "dominion_helpers.h"
        -:   21:#include "rngs.h"
        -:   22:#include "interface.h"
        -:   23:
        -:   24:#define DEBUG 0
        -:   25:#define NOISY_TEST 1
        -:   26:
function main called 1 returned 100% blocks executed 88%
        1:   27:int main(int argc, char *argv[])
        -:   28:{	
        -:   29:   // adventurer - treasure_map // Card 27
        -:   30:   int tempArray[NUM_K_CARDS]; // 
        -:   31:   int *t;
        -:   32:   int *kc;
        1:   33:   int fail = 0;
        1:   34:   int failcount = 0;
        -:   35:   
        1:   36:   srand(99);
call    0 returned 100%
        -:   37:   
        -:   38:      
        -:   39:   // initialize tempArray with unique values in the range adventurer to treasure_map
       11:   40:   for (int i = 0; i < NUM_K_CARDS; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
       10:   41:      int exists = 1;
        -:   42:      int r;
       30:   43:      while (exists) {
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
       10:   44:         exists = 0;
       10:   45:         r = rand() % (treasure_map - adventurer) + adventurer;
call    0 returned 100%
       10:   46:         assert(r <= treasure_map && r >= adventurer);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
       55:   47:         for (int f = 0; f < i; f++) {
branch  0 taken 82%
branch  1 taken 18% (fallthrough)
       45:   48:            if (r == tempArray[i]) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   49:               exists = 1;
    #####:   50:               break;
        -:   51:            }
        -:   52:         }
        -:   53:      }
       10:   54:      tempArray[i] = r;
        -:   55:   }
        -:   56:   
        -:   57:   // Test expected range of inputs
        1:   58:   t = tempArray;
        1:   59:   kc = kingdomCards(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9]);
call    0 returned 100%
       11:   60:   for (int i = 0; i < NUM_K_CARDS; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
       10:   61:      if (t[i] != kc[i] || kc[i] < adventurer || kc[i] > treasure_map){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####:   62:         fail = 1;
    #####:   63:         failcount++;
    #####:   64:         printf("FAIL: Card %d of kingdomCards failed to initialize correctly.\n", i);
call    0 never executed
        -:   65:      }
        -:   66:   }
        -:   67:   // Test out of range inputs
       11:   68:   for (int i = 0; i < NUM_K_CARDS; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
       10:   69:      if (i % 2 == 0) 
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        5:   70:         t[i] = INT_MAX;
        -:   71:      else
        5:   72:         t[i] = INT_MIN;
        -:   73:   }
        1:   74:   kc = kingdomCards(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9]);
call    0 returned 100%
       11:   75:   for (int i = 0; i < NUM_K_CARDS; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
       10:   76:      if (t[i] != kc[i] || kc[i] < adventurer || kc[i] > treasure_map){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
       10:   77:         fail = 1;
       10:   78:         failcount++;
       10:   79:         printf("FAIL: Card %d of kingdomCards failed to check for out of range input.\n", i);
call    0 returned 100%
        -:   80:      }
        -:   81:   }
        -:   82:   
        -:   83:   // Tests Complete
        1:   84:   if (fail) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   85:      printf("%d kingdomCards tests FAILED\n", failcount);
call    0 returned 100%
        1:   86:      return -1;
        -:   87:   }
        -:   88:   #if (NOISY_TEST == 1)
    #####:   89:      printf("All kingdomCards tests PASSED\n");
call    0 never executed
        -:   90:   #endif
    #####:   91:   return 0;
        -:   92:} 
*********************************************************
******************                     ******************
******************   unittest3.c.gcov  ******************
******************                     ******************
*********************************************************
 
        -:    0:Source:unittest3.c
        -:    0:Graph:unittest3.gcno
        -:    0:Data:unittest3.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*******************************************************************************
        -:    2:- Taylor Jenkins
        -:    3:- jenkitay@onid.oregonstate.edu
        -:    4:- CS 362 - Software Engineering II
        -:    5:- Assignment 3
        -:    6:- filename: unittest3.c
        -:    7:- Description: A unit test of the updateCoins() function in dominion.c.
        -:    8:- Compile instruction: 
        -:    9:gcc -g -Wall -std=c99 -fpic -coverage -lm unittest3.c dominion.o rngs.o -o unittest3
        -:   10:*******************************************************************************/
        -:   11:
        -:   12:#include <stdlib.h>
        -:   13:#include <string.h>
        -:   14:#include <stdio.h>
        -:   15:#include <math.h>
        -:   16:#include <assert.h>
        -:   17:#include <limits.h>
        -:   18:
        -:   19:#include "dominion.h"
        -:   20:#include "dominion_helpers.h"
        -:   21:#include "rngs.h"
        -:   22:#include "interface.h"
        -:   23:
        -:   24:#define DEBUG 0
        -:   25:#define NOISY_TEST 1
        -:   26:
function main called 1 returned 100% blocks executed 89%
        1:   27:int main(int argc, char *argv[])
        -:   28:{	
        -:   29:   // Game state variables
        1:   30:   int numPlayers = 2;
        -:   31:   int kCards[10] = {
        -:   32:      adventurer, 
        -:   33:      council_room, 
        -:   34:      feast, 
        -:   35:      gardens, 
        -:   36:      mine, 
        -:   37:      remodel, 
        -:   38:      smithy, 
        -:   39:      village, 
        -:   40:      baron, 
        1:   41:      great_hall};
        1:   42:   int randSeed = 99;
        -:   43:   struct gameState state;
        -:   44:   
        -:   45:   // test variables
        -:   46:   int p, c;
        1:   47:   int handCount = 0;
        1:   48:   int handCountMax = 5;
        1:   49:   int bonus = 0;
        1:   50:   int bonusMax = 10;
        1:   51:   int estateVal = 0;
        1:   52:   int copperVal = 1;
        1:   53:   int silverVal = 2;
        1:   54:   int goldVal = 3;
        1:   55:   int fail = 0;
        1:   56:   int failcount = 0;
        1:   57:   srand(randSeed);
call    0 returned 100%
        -:   58:   
        -:   59:   // initialize game state
        1:   60:   memset(&state, 0, sizeof(struct gameState)); // zero game state
        1:   61:   assert(initializeGame(numPlayers, kCards, randSeed, &state) == 0); // initializeGame returns 0 on success
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:   62:   
        -:   63:   // Begin Tests
        6:   64:   for (handCount = 1; handCount <= handCountMax; handCount++) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
       60:   65:      for (bonus = 0; bonus <= bonusMax; bonus++){
branch  0 taken 92%
branch  1 taken 8% (fallthrough)
      165:   66:         for (p = 0; p < numPlayers; p++) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
      110:   67:            state.handCount[p] = handCount;
        -:   68:         }
        -:   69:         // Test 1
        -:   70:         // set all cards in players hands to estate and check update coins
      165:   71:         for (p =0; p < numPlayers; p++) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
      440:   72:            for (c = 0; c < handCount; c++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
      330:   73:               state.hand[p][c] = estate;
        -:   74:            }
      110:   75:            updateCoins(p, &state, bonus);
call    0 returned 100%
        -:   76:            // coins should equal handCount * estateVal + bonus
      110:   77:            if (state.coins != handCount * estateVal + bonus) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   78:               fail = 1;
    #####:   79:               failcount++;
    #####:   80:               printf("FAIL Test 1: %d estate cards + %d bonus returned %d coins. Expected %d coins.\n"
call    0 never executed
    #####:   81:                  , handCount, bonus, state.coins, handCount * estateVal + bonus);
        -:   82:            }
        -:   83:         }
        -:   84:         // Test 2
        -:   85:         // set all cards in players hands to copper and check update coins
      165:   86:         for (p =0; p < numPlayers; p++) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
      440:   87:            for (c = 0; c < handCount; c++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
      330:   88:               state.hand[p][c] = copper;
        -:   89:            }
      110:   90:            updateCoins(p, &state, bonus);
call    0 returned 100%
        -:   91:            // coins should equal handCount * copperVal + bonus
      110:   92:            if (state.coins != handCount * copperVal + bonus) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   93:               fail = 1;
    #####:   94:               failcount++;
    #####:   95:               printf("FAIL Test 2: %d copper cards + %d bonus returned %d coins. Expected %d coins.\n"
call    0 never executed
    #####:   96:                  , handCount, bonus, state.coins, handCount * copperVal + bonus);
        -:   97:            }
        -:   98:         }
        -:   99:         // Test 3
        -:  100:         // set all cards in players hands to silver and check update coins
      165:  101:         for (p =0; p < numPlayers; p++) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
      440:  102:            for (c = 0; c < handCount; c++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
      330:  103:               state.hand[p][c] = silver;
        -:  104:            }
      110:  105:            updateCoins(p, &state, bonus);
call    0 returned 100%
        -:  106:            // coins should equal handCount * silverVal + bonus
      110:  107:            if (state.coins != handCount * silverVal + bonus) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  108:               fail = 1;
    #####:  109:               failcount++;
    #####:  110:               printf("FAIL Test 3: %d silver cards + %d bonus returned %d coins. Expected %d coins.\n"
call    0 never executed
    #####:  111:                  , handCount, bonus, state.coins, handCount * silverVal + bonus);
        -:  112:            }
        -:  113:         }
        -:  114:         // Test 4
        -:  115:         // set all cards in players hands to gold and check update coins
      165:  116:         for (p =0; p < numPlayers; p++) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
      440:  117:            for (c = 0; c < handCount; c++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
      330:  118:               state.hand[p][c] = gold;
        -:  119:            }
      110:  120:            updateCoins(p, &state, bonus);
call    0 returned 100%
        -:  121:            // coins should equal handCount * goldVal + bonus
      110:  122:            if (state.coins != handCount * goldVal + bonus) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  123:               fail = 1;
    #####:  124:               failcount++;
    #####:  125:               printf("FAIL Test 4: %d gold cards + %d bonus returned %d coins. Expected %d coins.\n"
call    0 never executed
    #####:  126:                  , handCount, bonus, state.coins, handCount * goldVal + bonus);
        -:  127:            }
        -:  128:         }
        -:  129:         // Test 5
        -:  130:         // set all cards in players hands to mix of estate, copper, silver and gold
        -:  131:         // and check update coins
      165:  132:         for (p =0; p < numPlayers; p++) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
      110:  133:            int numE = 0;
      110:  134:            int numC = 0;
      110:  135:            int numS = 0;
      110:  136:            int numG = 0;
      440:  137:            for (c = 0; c < handCount; c++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
      330:  138:               if (c % 4 == 0) {
branch  0 taken 40% (fallthrough)
branch  1 taken 60%
      132:  139:                  numE++;
      132:  140:                  state.hand[p][c] = estate;
        -:  141:               }
      330:  142:               if (c % 4 == 1) {
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
       88:  143:                  numC++;
       88:  144:                  state.hand[p][c] = copper;
        -:  145:               }
      330:  146:               if (c % 4 == 2) {
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
       66:  147:                  numS++;
       66:  148:                  state.hand[p][c] = silver;
        -:  149:               }
      330:  150:               if (c % 4 == 3) {
branch  0 taken 13% (fallthrough)
branch  1 taken 87%
       44:  151:                  numG++;
       44:  152:                  state.hand[p][c] = gold;
        -:  153:               }
        -:  154:            }
      110:  155:            updateCoins(p, &state, bonus);
call    0 returned 100%
        -:  156:            // coins should equal (numE * estateVal + numC * copperVal 
        -:  157:            //    + numS * silverVal +numG * goldVal + bonus)
        -:  158:            int total = numE * estateVal 
      110:  159:                      + numC * copperVal 
      110:  160:                      + numS * silverVal 
      110:  161:                      + numG * goldVal 
      220:  162:                      + bonus;
      110:  163:            if (state.coins != total) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  164:               fail = 1;
    #####:  165:               failcount++;
    #####:  166:               printf("FAIL Test 4: %d mixed cards + %d bonus returned %d coins. Expected %d coins.\n"
call    0 never executed
        -:  167:                  , handCount, bonus, state.coins, total);
        -:  168:            }
        -:  169:         }
        -:  170:      }
        -:  171:   }
        -:  172:   
        -:  173:   // Tests Complete
        1:  174:   if (fail) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  175:      printf("%d updateCoins() tests FAILED\n", failcount);
call    0 never executed
    #####:  176:      return -1;
        -:  177:   }
        -:  178:   #if (NOISY_TEST == 1)
        1:  179:      printf("All updateCoins() tests PASSED\n");
call    0 returned 100%
        -:  180:   #endif
        1:  181:   return 0;
        -:  182:} 
*********************************************************
******************                     ******************
******************   unittest4.c.gcov  ******************
******************                     ******************
*********************************************************
 
        -:    0:Source:unittest4.c
        -:    0:Graph:unittest4.gcno
        -:    0:Data:unittest4.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*******************************************************************************
        -:    2:- Taylor Jenkins
        -:    3:- jenkitay@onid.oregonstate.edu
        -:    4:- CS 362 - Software Engineering II
        -:    5:- Assignment 3
        -:    6:- filename: unittest4.c
        -:    7:- Description: A unit test of the discardCard() function in dominion.c.
        -:    8:- Compile instruction: 
        -:    9:gcc -g -Wall -std=c99 -fpic -coverage -lm unittest4.c dominion.o rngs.o -o unittest4
        -:   10:*******************************************************************************/
        -:   11:
        -:   12:#include <stdlib.h>
        -:   13:#include <string.h>
        -:   14:#include <stdio.h>
        -:   15:#include <math.h>
        -:   16:#include <assert.h>
        -:   17:#include <limits.h>
        -:   18:
        -:   19:#include "dominion.h"
        -:   20:#include "dominion_helpers.h"
        -:   21:#include "rngs.h"
        -:   22:#include "interface.h"
        -:   23:
        -:   24:#define DEBUG 0
        -:   25:#define NOISY_TEST 1
        -:   26:
function main called 1 returned 100% blocks executed 58%
        1:   27:int main(int argc, char *argv[])
        -:   28:{	
        -:   29:   // Game state variables
        1:   30:   int numPlayers = 2;
        -:   31:   int kCards[10] = {
        -:   32:      adventurer, 
        -:   33:      council_room, 
        -:   34:      feast, 
        -:   35:      gardens, 
        -:   36:      mine, 
        -:   37:      remodel, 
        -:   38:      smithy, 
        -:   39:      village, 
        -:   40:      baron, 
        1:   41:      great_hall};
        1:   42:   int randSeed = 99;
        -:   43:   struct gameState state;
        -:   44:   
        -:   45:   // test variables
        -:   46:   int p;
        -:   47:   int temp;
        -:   48:   int handPos;
        1:   49:   int trash = 1;
        1:   50:   int noTrash = 0;
        1:   51:   int handCount = 0;
        1:   52:   int handCountMax = 5;
        1:   53:   int fail = 0;
        1:   54:   int failcount = 0;
        1:   55:   srand(randSeed);
call    0 returned 100%
        -:   56:   
        -:   57:   // initialize game state
        1:   58:   memset(&state, -1, sizeof(struct gameState)); // initialize game state
        1:   59:   assert(initializeGame(numPlayers, kCards, randSeed, &state) == 0); // initializeGame returns 0 on success
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:   60:   
        -:   61:   // Begin Tests
        6:   62:   for (handCount = 1; handCount <= handCountMax; handCount++) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
       15:   63:      for (p = 0; p < numPlayers; p++) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:   64:        
        -:   65:         // Test 1   Trash the last card in the hand
        -:   66:         // Set the size of the hand, and playedCardCount
       10:   67:         state.handCount[p] = handCount;
       10:   68:         state.playedCardCount = 0;
        -:   69:         // set all cards in the hand to kCards[handPos % (length of kCards)] 
       40:   70:         for (handPos = 0; handPos < handCount; handPos++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
       30:   71:            state.hand[p][handPos] = kCards[handPos % (sizeof(kCards)/sizeof(int))];
        -:   72:         }
        -:   73:         // trash the last card in hand
       10:   74:         handPos = handCount - 1;
       10:   75:         discardCard(handPos, p, &state, trash);
call    0 returned 100%
        -:   76:         // played card count should remain unchanged
       10:   77:         if (state.playedCardCount != 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   78:            fail = 1;
    #####:   79:            failcount++;
    #####:   80:            printf("FAIL Test 1: playedCardCount was changed on trash\n");
call    0 never executed
    #####:   81:            printf("\thandCount = %d Player = %d\n", handCount, p);
call    0 never executed
        -:   82:         }
        -:   83:         // handCount should be reduced by 1
       10:   84:         if (state.handCount[p] != handCount - 1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   85:            fail = 1;
    #####:   86:            failcount++;
    #####:   87:            printf("FAIL Test 1: Hand count not reduced by 1\n");
call    0 never executed
    #####:   88:            printf("\thandCount = %d Player = %d\n", handCount, p);
call    0 never executed
        -:   89:         }
        -:   90:      
        -:   91:         // Test 2   Discard last card in hand onto empty discard pile
        -:   92:         // Set the size of the hand, and playedCardCount
       10:   93:         state.handCount[p] = handCount;
       10:   94:         state.playedCardCount = 0;
        -:   95:         // set all cards in the hand to kCards[handPos % (length of kCards)] 
       40:   96:         for (handPos = 0; handPos < handCount; handPos++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
       30:   97:            state.hand[p][handPos] = kCards[handPos % (sizeof(kCards)/sizeof(int))];
        -:   98:         }
        -:   99:         // discard the last card in hand
       10:  100:         handPos = handCount - 1;
       10:  101:         temp = state.hand[p][handPos];
       10:  102:         discardCard(handPos, p, &state, noTrash);
call    0 returned 100%
        -:  103:         // Should not allow played card out of range of hand
       10:  104:         if (state.playedCards[state.playedCardCount - 1] != temp) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  105:            fail = 1;
    #####:  106:            failcount++;
    #####:  107:            printf("FAIL Test 2: played card did not match card in handPos\n");
call    0 never executed
    #####:  108:            printf("\tExpected: %d. Returned %d.\n", temp, 
call    0 never executed
    #####:  109:                  state.playedCards[state.playedCardCount - 1]);
    #####:  110:            printf("\thandCount = %d Player = %d\n", handCount, p);
call    0 never executed
        -:  111:         }
        -:  112:         // Should not allow played card out of range of hand
       10:  113:         if (state.playedCards[state.playedCardCount - 1] == -1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  114:            fail = 1;
    #####:  115:            failcount++;
    #####:  116:            printf("FAIL Test 2: played card was out of range for hand\n");
call    0 never executed
    #####:  117:            printf("\thandCount = %d Player = %d\n", handCount, p);
call    0 never executed
        -:  118:         }
        -:  119:         // played card count should remain unchanged
       10:  120:         if (state.playedCardCount != 1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  121:            fail = 1;
    #####:  122:            failcount++;
    #####:  123:            printf("FAIL Test 2: playedCardCount wasn't incremented on discard\n");
call    0 never executed
    #####:  124:            printf("\thandCount = %d Player = %d\n", handCount, p);
call    0 never executed
        -:  125:         }
        -:  126:         // handCount should be reduced by 1
       10:  127:         if (state.handCount[p] != handCount - 1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  128:            fail = 1;
    #####:  129:            failcount++;
    #####:  130:            printf("FAIL Test 2: Hand count not reduced by 1\n");
call    0 never executed
    #####:  131:            printf("\thandCount = %d Player = %d\n", handCount, p);
call    0 never executed
        -:  132:         }
        -:  133:         
        -:  134:         // Test 3   Discard first card in hand onto discard pile
        -:  135:         // Set the size of the hand, and playedCardCount
       10:  136:         state.handCount[p] = handCount;
       10:  137:         state.playedCardCount = 5;
        -:  138:         // set all cards in the hand to kCards[handPos % (length of kCards)] 
       40:  139:         for (handPos = 0; handPos < handCount; handPos++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
       30:  140:            state.hand[p][handPos] = kCards[handPos % (sizeof(kCards)/sizeof(int))];
        -:  141:         }
        -:  142:         // discard the first card in hand
       10:  143:         handPos = 0;
       10:  144:         temp = state.hand[p][handPos];
       10:  145:         discardCard(handPos, p, &state, noTrash);
call    0 returned 100%
        -:  146:         // Should not allow played card out of range of hand
       10:  147:         if (state.playedCards[state.playedCardCount - 1] != temp) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  148:            fail = 1;
    #####:  149:            failcount++;
    #####:  150:            printf("FAIL Test 3: played card did not match card in handPos\n");
call    0 never executed
    #####:  151:            printf("\tExpected: %d. Returned %d.\n", temp, 
call    0 never executed
    #####:  152:                  state.playedCards[state.playedCardCount - 1]);
    #####:  153:            printf("\thandCount = %d Player = %d\n", handCount, p);
call    0 never executed
        -:  154:         }
        -:  155:         // Should not allow played card out of range of hand
       10:  156:         if (state.playedCards[state.playedCardCount - 1] == -1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  157:            fail = 1;
    #####:  158:            failcount++;
    #####:  159:            printf("FAIL Test 3: played card was out of range for hand\n");
call    0 never executed
    #####:  160:            printf("\thandCount = %d Player = %d\n", handCount, p);
call    0 never executed
        -:  161:         }
        -:  162:         // played card count should remain unchanged
       10:  163:         if (state.playedCardCount != 6) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  164:            fail = 1;
    #####:  165:            failcount++;
    #####:  166:            printf("FAIL Test 3: playedCardCount wasn't incremented on discard\n");
call    0 never executed
    #####:  167:            printf("\thandCount = %d Player = %d\n", handCount, p);
call    0 never executed
        -:  168:         }
        -:  169:         // handCount should be reduced by 1
       10:  170:         if (state.handCount[p] != handCount - 1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  171:            fail = 1;
    #####:  172:            failcount++;
    #####:  173:            printf("FAIL Test 3: Hand count not reduced by 1\n");
call    0 never executed
    #####:  174:            printf("\thandCount = %d Player = %d\n", handCount, p);
call    0 never executed
        -:  175:         }
        -:  176:         
        -:  177:         // Test 4   Discard second card in hand onto discard pile
        -:  178:         // Set the size of the hand, and playedCardCount
       10:  179:         state.handCount[p] = handCount;
       10:  180:         state.playedCardCount = 3;
        -:  181:         // test second card in hand
       10:  182:         int testPos = 1;
       10:  183:         state.hand[p][testPos] = -1;
        -:  184:         // set all cards in the hand to kCards[handPos % (length of kCards)] 
       40:  185:         for (handPos = 0; handPos < handCount; handPos++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
       30:  186:            state.hand[p][handPos] = kCards[handPos % (sizeof(kCards)/sizeof(int))];
        -:  187:         }
        -:  188:         // discard the second card in hand
       10:  189:         temp = state.hand[p][testPos];
       10:  190:         handPos = testPos;
       10:  191:         discardCard(handPos, p, &state, noTrash);
call    0 returned 100%
        -:  192:         // Should not allow played card out of range of hand
       10:  193:         if (state.playedCards[state.playedCardCount - 1] != temp) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  194:            fail = 1;
    #####:  195:            failcount++;
    #####:  196:            printf("FAIL Test 4: played card did not match card in handPos\n");
call    0 never executed
    #####:  197:            printf("\tExpected: %d. Returned %d.\n", temp, 
call    0 never executed
    #####:  198:                  state.playedCards[state.playedCardCount - 1]);
    #####:  199:            printf("\thandCount = %d Player = %d\n", handCount, p);
call    0 never executed
        -:  200:         }
        -:  201:         // Should not allow played card out of range of hand
       10:  202:         if (state.playedCards[state.playedCardCount - 1] == -1) {
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
        2:  203:            fail = 1;
        2:  204:            failcount++;
        2:  205:            printf("FAIL Test 4: played card was out of range for hand\n");
call    0 returned 100%
        2:  206:            printf("\thandCount = %d Player = %d\n", handCount, p);
call    0 returned 100%
        -:  207:         }
        -:  208:         // played card count should remain unchanged
       10:  209:         if (state.playedCardCount != 4) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  210:            fail = 1;
    #####:  211:            failcount++;
    #####:  212:            printf("FAIL Test 4: playedCardCount wasn't incremented on discard\n");
call    0 never executed
    #####:  213:            printf("\thandCount = %d Player = %d\n", handCount, p);
call    0 never executed
        -:  214:         }
        -:  215:         // handCount should be reduced by 1
       10:  216:         if (state.handCount[p] != handCount - 1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  217:            fail = 1;
    #####:  218:            failcount++;
    #####:  219:            printf("FAIL Test 4: Hand count not reduced by 1\n");
call    0 never executed
    #####:  220:            printf("\thandCount = %d Player = %d\n", handCount, p);
call    0 never executed
        -:  221:         }
        -:  222:         
        -:  223:      }
        -:  224:   }
        -:  225:   
        -:  226:   // Tests Complete
        1:  227:   if (fail) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  228:      printf("%d discardCard() tests FAILED\n", failcount);
call    0 returned 100%
        1:  229:      return -1;
        -:  230:   }
        -:  231:   #if (NOISY_TEST == 1)
    #####:  232:      printf("All discardCard() tests PASSED\n");
call    0 never executed
        -:  233:   #endif
    #####:  234:   return 0;
        -:  235:} 
*********************************************************
******************                     ******************
******************   cardtest1.c.gcov  ******************
******************                     ******************
*********************************************************
 
        -:    0:Source:cardtest1.c
        -:    0:Graph:cardtest1.gcno
        -:    0:Data:cardtest1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*******************************************************************************
        -:    2:- Taylor Jenkins
        -:    3:- jenkitay@onid.oregonstate.edu
        -:    4:- CS 362 - Software Engineering II
        -:    5:- Assignment 3
        -:    6:- filename: cardtest1.c
        -:    7:- Description: A unit test of the smithy card in dominion.c.
        -:    8:- Compile instruction: 
        -:    9:gcc -g -Wall -std=c99 -fpic -coverage -lm cardtest1.c dominion.o rngs.o -o cardtest1
        -:   10:*******************************************************************************/
        -:   11:
        -:   12:#include <stdlib.h>
        -:   13:#include <string.h>
        -:   14:#include <stdio.h>
        -:   15:#include <math.h>
        -:   16:#include <assert.h>
        -:   17:#include <limits.h>
        -:   18:
        -:   19:#include "dominion.h"
        -:   20:#include "dominion_helpers.h"
        -:   21:#include "rngs.h"
        -:   22:#include "interface.h"
        -:   23:
        -:   24:#define DEBUG 0
        -:   25:#define NOISY_TEST 1
        -:   26:
        -:   27:int smithyCardEffect(struct gameState *state, int handPos);
        -:   28:
function main called 1 returned 100% blocks executed 92%
        1:   29:int main(int argc, char *argv[])
        -:   30:{	
        -:   31:   // Game state variables
        1:   32:   int numPlayers = 2;
        -:   33:   int kCards[10] = {
        -:   34:      adventurer, 
        -:   35:      council_room, 
        -:   36:      feast, 
        -:   37:      gardens, 
        -:   38:      mine, 
        -:   39:      remodel, 
        -:   40:      smithy, 
        -:   41:      village, 
        -:   42:      baron, 
        1:   43:      great_hall};
        1:   44:   int randSeed = 99;
        -:   45:   struct gameState state;
        -:   46:   
        -:   47:   // test variables
        -:   48:   int p;
        -:   49:   //int res;
        -:   50:   int handPos;
        1:   51:   int handCount = 0;
        1:   52:   int handCountMax = 5;
        1:   53:   int fail = 0;
        1:   54:   int failcount = 0;
        -:   55:   
        -:   56:   /* For Reference, elements of game state struct:
        -:   57:         int whoseTurn;
        -:   58:         int hand[MAX_PLAYERS][MAX_HAND];
        -:   59:         int handCount[MAX_PLAYERS];
        -:   60:         int deck[MAX_PLAYERS][MAX_DECK];
        -:   61:         int deckCount[MAX_PLAYERS];
        -:   62:         int discard[MAX_PLAYERS][MAX_DECK];
        -:   63:         int discardCount[MAX_PLAYERS];
        -:   64:         int playedCards[MAX_DECK];
        -:   65:         int playedCardCount;
        -:   66:    */
        -:   67:   
        -:   68:   // initialize game state
        1:   69:   memset(&state, -1, sizeof(struct gameState)); // initialize game state
        1:   70:   assert(initializeGame(numPlayers, kCards, randSeed, &state) == 0); // initializeGame returns 0 on success
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:   71:   
        -:   72:   // Begin Tests
        6:   73:   for (handCount = 1; handCount <= handCountMax; handCount++) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
       15:   74:      for (p = 0; p < numPlayers; p++) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
       10:   75:         state.whoseTurn = p;
        -:   76:         
        -:   77:         // Test:  play smithy card removes 1 card from hand, adds 3 cards to 
        -:   78:         //        hand, removes 3 from deck, and adds 1 card to discard 
        -:   79:         // Set the size of the hand, and playedCardCount
       10:   80:         state.handCount[p] = handCount;
       10:   81:         state.discardCount[p] = 4;
       10:   82:         state.playedCardCount = 4;
       10:   83:         state.deckCount[p] = 4;
       10:   84:         state.deck[p][0] = adventurer;
       10:   85:         state.deck[p][1] = feast;
       10:   86:         state.deck[p][2] = gold;
       10:   87:         state.deck[p][3] = copper;
       10:   88:         int startHandCount = state.handCount[p];
       10:   89:         int startDeckCount = state.deckCount[p];
       10:   90:         int startDiscardCount = state.discardCount[p];
       10:   91:         int startPlayedCardCount = state.playedCardCount;
        -:   92:         
        -:   93:         
        -:   94:         // set all cards in the hand to kCards[handPos % (length of kCards)] 
       40:   95:         for (handPos = 0; handPos < handCount; handPos++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
       30:   96:            state.hand[p][handPos] = kCards[handPos % (sizeof(kCards)/sizeof(int))];
        -:   97:         }
       10:   98:         handPos = 0;
       10:   99:         state.hand[p][handPos] = smithy;
        -:  100:         
        -:  101:         #if (NOISY_TEST == 1)
       10:  102:            printf("Pre-conditions:\n handCount = %d\n deckCount = %d\n discardCount = %d\n playedCardCount = %d\n turn = %d\n"
call    0 returned 100%
        -:  103:                  , startHandCount, startDeckCount, startDiscardCount, startPlayedCardCount, state.whoseTurn);
        -:  104:         
        -:  105:         #endif
        -:  106:         
       10:  107:         smithyCardEffect(&state, handPos);
call    0 returned 100%
        -:  108:         
        -:  109:         #if (NOISY_TEST == 1)
       10:  110:            printf("Post-conditions:\n handCount = %d\n deckCount = %d\n discardCount = %d\n playedCardCount = %d\n turn = %d\n"
call    0 returned 100%
        -:  111:                  , state.handCount[p], state.deckCount[p], state.discardCount[p], state.playedCardCount, state.whoseTurn);
        -:  112:         
        -:  113:         #endif
        -:  114:         
        -:  115:         // hand count should have 2 more cards (add 3 minus discard smithy)
       10:  116:         if (state.handCount[p] != startHandCount + 2) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       10:  117:            fail = 1;
       10:  118:            failcount++;
       10:  119:            printf("FAIL Test 1: handCount did not increase by two\n");
call    0 returned 100%
       10:  120:            printf("\tExpected: %d. Returned: %d\n", startHandCount + 2, state.handCount[p]);
call    0 returned 100%
       10:  121:            printf("\tstarting handCount = %d Player = %d\n", startHandCount, p);
call    0 returned 100%
        -:  122:         }
        -:  123:         // deckCount should have decreased by 3.
       10:  124:         if (state.deckCount[p] != startDeckCount - 3) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       10:  125:            fail = 1;
       10:  126:            failcount++;
       10:  127:            printf("FAIL Test 2: deckCount did not decrease by three\n");
call    0 returned 100%
       10:  128:            printf("\tExpected: %d. Returned: %d\n", startDeckCount - 3, state.deckCount[p]);
call    0 returned 100%
       10:  129:            printf("\tstarting handCount = %d Player = %d\n", startHandCount, p);
call    0 returned 100%
        -:  130:         }
        -:  131:         // discard count should have increased by 1
       10:  132:         if (state.discardCount[p] != startDiscardCount + 1) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       10:  133:            fail = 1;
       10:  134:            failcount++;
       10:  135:            printf("FAIL Test 3: discardCount count not increased by 1\n");
call    0 returned 100%
       10:  136:            printf("\tExpected: %d. Returned: %d\n", startDiscardCount + 1, state.discardCount[p]);
call    0 returned 100%
       10:  137:            printf("\tstarting handCount = %d Player = %d\n", startHandCount, p);
call    0 returned 100%
        -:  138:         }
        -:  139:         // playedCardCount should have increased by 1
       10:  140:         if (state.playedCardCount != startPlayedCardCount + 1) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       10:  141:            fail = 1;
       10:  142:            failcount++;
       10:  143:            printf("FAIL Test 4: playedCardCount count not increased by 1\n");
call    0 returned 100%
       10:  144:            printf("\tExpected: %d. Returned: %d\n", startPlayedCardCount + 1, state.playedCardCount);
call    0 returned 100%
       10:  145:            printf("\tstarting handCount = %d Player = %d\n", startHandCount, p);
call    0 returned 100%
        -:  146:         }
        -:  147:         
        -:  148:      }
        -:  149:   }
        -:  150:   
        -:  151:   // Tests Complete
        1:  152:   if (fail) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  153:      printf("%d smithy tests FAILED\n", failcount);
call    0 returned 100%
        1:  154:      return -1;
        -:  155:   }
        -:  156:   #if (NOISY_TEST == 1)
    #####:  157:      printf("All smithy tests PASSED\n");
call    0 never executed
        -:  158:   #endif
    #####:  159:   return 0;
        -:  160:} 
*********************************************************
******************                     ******************
******************   cardtest2.c.gcov  ******************
******************                     ******************
*********************************************************
 
        -:    0:Source:cardtest2.c
        -:    0:Graph:cardtest2.gcno
        -:    0:Data:cardtest2.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*******************************************************************************
        -:    2:- Taylor Jenkins
        -:    3:- jenkitay@onid.oregonstate.edu
        -:    4:- CS 362 - Software Engineering II
        -:    5:- Assignment 3
        -:    6:- filename: cardtest2.c
        -:    7:- Description: A unit test of the adventurer card in dominion.c.
        -:    8:- Compile instruction: 
        -:    9:gcc -g -Wall -std=c99 -fpic -coverage -lm cardtest2.c dominion.o rngs.o -o cardtest2
        -:   10:*******************************************************************************/
        -:   11:
        -:   12:#include <stdlib.h>
        -:   13:#include <string.h>
        -:   14:#include <stdio.h>
        -:   15:#include <math.h>
        -:   16:#include <assert.h>
        -:   17:#include <limits.h>
        -:   18:
        -:   19:#include "dominion.h"
        -:   20:#include "dominion_helpers.h"
        -:   21:#include "rngs.h"
        -:   22:#include "interface.h"
        -:   23:
        -:   24:#define DEBUG 0
        -:   25:#define NOISY_TEST 1
        -:   26:
        -:   27:int adventurerCardEffect(struct gameState *state);
        -:   28:
function main called 1 returned 100% blocks executed 88%
        1:   29:int main(int argc, char *argv[])
        -:   30:{	
        -:   31:   // Game state variables
        1:   32:   int numPlayers = 2;
        -:   33:   int kCards[10] = {
        -:   34:      adventurer, 
        -:   35:      council_room, 
        -:   36:      feast, 
        -:   37:      gardens, 
        -:   38:      mine, 
        -:   39:      remodel, 
        -:   40:      smithy, 
        -:   41:      village, 
        -:   42:      baron, 
        1:   43:      great_hall};
        1:   44:   int randSeed = 99;
        -:   45:   struct gameState state;
        -:   46:   
        -:   47:   // test variables
        -:   48:   int p;
        -:   49:   //int res;
        -:   50:   int handPos;
        1:   51:   int handCount = 0;
        1:   52:   int handCountMax = 5;
        1:   53:   int fail = 0;
        1:   54:   int failcount = 0;
        -:   55:   int initHand[] = {
        -:   56:      adventurer,
        -:   57:      copper,
        -:   58:      estate,
        -:   59:      copper,
        -:   60:      estate,
        1:   61:   };
        -:   62:      
        -:   63:   /* For Reference, elements of game state struct:
        -:   64:         int whoseTurn;
        -:   65:         int hand[MAX_PLAYERS][MAX_HAND];
        -:   66:         int handCount[MAX_PLAYERS];
        -:   67:         int deck[MAX_PLAYERS][MAX_DECK];
        -:   68:         int deckCount[MAX_PLAYERS];
        -:   69:         int discard[MAX_PLAYERS][MAX_DECK];
        -:   70:         int discardCount[MAX_PLAYERS];
        -:   71:         int playedCards[MAX_DECK];
        -:   72:         int playedCardCount;
        -:   73:    */
        -:   74:   
        -:   75:   // initialize game state
        1:   76:   memset(&state, -1, sizeof(struct gameState)); // initialize game state
        1:   77:   assert(initializeGame(numPlayers, kCards, randSeed, &state) == 0); // initializeGame returns 0 on success
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:   78:   
        -:   79:   // Begin Tests
        6:   80:   for (handCount = 1; handCount <= handCountMax; handCount++) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
       15:   81:      for (p = 0; p < numPlayers; p++) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
       10:   82:         state.whoseTurn = p;
        -:   83:         
        -:   84:         // Test:  Effect of adventurer card
        -:   85:         //    Reveal cards from your deck until you reveal 2 Treasure cards. 
        -:   86:         //    Put those Treasure cards in your hand and discard the other 
        -:   87:         //    revealed cards.
        -:   88:         
        -:   89:         // initialize player's hand
       10:   90:         state.handCount[p] = handCount;
       40:   91:         for (handPos = 0; handPos < handCount; handPos++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
       30:   92:            state.hand[p][handPos] = initHand[handPos % (sizeof(initHand)/sizeof(int))];
        -:   93:         }
        -:   94:         
        -:   95:         // initialize counts
       10:   96:         state.discardCount[p] = 0;
       10:   97:         state.playedCardCount = 0;
        -:   98:         
        -:   99:         // initialize deck
       10:  100:         state.deckCount[p] = 7;
       10:  101:         state.deck[p][0] = adventurer;
       10:  102:         state.deck[p][1] = gold;
       10:  103:         state.deck[p][2] = feast;
       10:  104:         state.deck[p][3] = copper;
       10:  105:         state.deck[p][4] = mine;
       10:  106:         state.deck[p][5] = smithy;
       10:  107:         state.deck[p][6] = silver;
        -:  108:         
       10:  109:         handPos = 0;
        -:  110:         
        -:  111:         // save precondition state in variables.
       10:  112:         int startHandCount = state.handCount[p];
       10:  113:         int startDeckCount = state.deckCount[p];
       10:  114:         int startDiscardCount = state.discardCount[p];
       10:  115:         int startPlayedCardCount = state.playedCardCount;
       10:  116:         int startDeck[state.deckCount[p]];
       80:  117:         for (int i = 0; i < state.deckCount[p]; i++) {
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
       70:  118:            startDeck[i] = state.deck[p][i];
        -:  119:         }
        -:  120:         
        -:  121:         // print preconditions
        -:  122:         #if (NOISY_TEST == 1)
       10:  123:            printf("Pre-conditions:\n handCount = %d\n deckCount = %d\n discardCount = %d\n playedCardCount = %d\n turn = %d\n"
call    0 returned 100%
        -:  124:                  , startHandCount, startDeckCount, startDiscardCount, startPlayedCardCount, state.whoseTurn);
        -:  125:         
        -:  126:         #endif
        -:  127:         
        -:  128:         // play adventurer card
       10:  129:         adventurerCardEffect(&state);
call    0 returned 100%
        -:  130:         
        -:  131:         // print post conditions
        -:  132:         #if (NOISY_TEST == 1)
       10:  133:            printf("Post-conditions:\n handCount = %d\n deckCount = %d\n discardCount = %d\n playedCardCount = %d\n turn = %d\n"
call    0 returned 100%
        -:  134:                  , state.handCount[p], state.deckCount[p], state.discardCount[p], state.playedCardCount, state.whoseTurn);
        -:  135:         
        -:  136:         #endif
        -:  137:         
        -:  138:         // Test 1: hand count should have 2 more cards
       10:  139:         if (state.handCount[p] != startHandCount + 2) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       10:  140:            fail = 1;
       10:  141:            failcount++;
       10:  142:            printf("FAIL Test 1: handCount did not increase by 2\n");
call    0 returned 100%
       10:  143:            printf("\tExpected: %d. Returned: %d\n"
call    0 returned 100%
        -:  144:               , startHandCount + 2, state.handCount[p]);
       10:  145:            printf("\tstarting handCount = %d Player = %d\n", startHandCount, p);
call    0 returned 100%
        -:  146:         }
        -:  147:         // Test 2: deckCount should have decreased by 4.
       10:  148:         if (state.deckCount[p] != startDeckCount - 4) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       10:  149:            fail = 1;
       10:  150:            failcount++;
       10:  151:            printf("FAIL Test 2: deckCount did not decrease by 4\n");
call    0 returned 100%
       10:  152:            printf("\tExpected: %d. Returned: %d\n"
call    0 returned 100%
        -:  153:               , startDeckCount - 4, state.deckCount[p]);
       10:  154:            printf("\tstarting handCount = %d Player = %d\n", startHandCount, p);
call    0 returned 100%
        -:  155:         }
        -:  156:         // Test 3: discard count should have increased by 2
       10:  157:         if (state.discardCount[p] != startDiscardCount + 2) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       10:  158:            fail = 1;
       10:  159:            failcount++;
       10:  160:            printf("FAIL Test 3: discardCount count not increased by 2\n");
call    0 returned 100%
       10:  161:            printf("\tExpected: %d. Returned: %d\n"
call    0 returned 100%
        -:  162:               , startDiscardCount + 2, state.discardCount[p]);
       10:  163:            printf("\tstarting handCount = %d Player = %d\n", startHandCount, p);
call    0 returned 100%
        -:  164:         }
        -:  165:         // Test 4: playedCardCount should remain unchanged
       10:  166:         if (state.playedCardCount != startPlayedCardCount) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  167:            fail = 1;
    #####:  168:            failcount++;
    #####:  169:            printf("FAIL Test 4: playedCardCount changed\n");
call    0 never executed
    #####:  170:            printf("\tExpected: %d. Returned: %d\n"
call    0 never executed
        -:  171:               , startPlayedCardCount, state.playedCardCount);
    #####:  172:            printf("\tstarting handCount = %d Player = %d\n", startHandCount, p);
call    0 never executed
        -:  173:         }
        -:  174:         // Test 5: discard pile should contain mine and smithy in that order.
       20:  175:         if (state.discard[p][0] != startDeck[4] // mine
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
       10:  176:            && state.discard[p][1] != startDeck[5] ) { // smithy
       10:  177:            fail = 1;
       10:  178:            failcount++;
       10:  179:            printf("FAIL Test 5: discard pile does not contain mine and smithy in that order.\n");
call    0 returned 100%
       10:  180:            printf("\tExpected: [%d, %d]. Returned: [%d, %d]\n"
call    0 returned 100%
        -:  181:               , mine, smithy, state.discard[p][0], state.discard[p][1]);
       10:  182:            printf("\tstarting handCount = %d Player = %d\n", startHandCount, p);
call    0 returned 100%
        -:  183:         }
        -:  184:         // Test 6: Last two cards in hand should be silver and copper in that order.
       20:  185:         if (state.hand[p][startHandCount] != startDeck[6] // silver
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 70% (fallthrough)
branch  3 taken 30%
       10:  186:            && state.hand[p][startHandCount + 1] != startDeck[3] ) { // copper
        7:  187:            fail = 1;
        7:  188:            failcount++;
        7:  189:            printf("FAIL Test 6: Last two cards in hand are not silver and copper in that order.\n");
call    0 returned 100%
       14:  190:            printf("\tExpected: [%d, %d]. Returned: [%d, %d]\n", silver, copper
call    0 returned 100%
        7:  191:               , state.hand[p][startHandCount], state.hand[p][startHandCount + 1]);
        7:  192:            printf("\tstarting handCount = %d Player = %d\n", startHandCount, p);
call    0 returned 100%
        -:  193:         }
        -:  194:         
        -:  195:      }
        -:  196:   }
        -:  197:   
        -:  198:   // Tests Complete
        1:  199:   if (fail) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  200:      printf("%d adventurer tests FAILED\n", failcount);
call    0 returned 100%
        1:  201:      return -1;
        -:  202:   }
        -:  203:   #if (NOISY_TEST == 1)
    #####:  204:      printf("All adventurer tests PASSED\n");
call    0 never executed
        -:  205:   #endif
    #####:  206:   return 0;
        -:  207:} 
*********************************************************
******************                     ******************
******************   cardtest3.c.gcov  ******************
******************                     ******************
*********************************************************
 
        -:    0:Source:cardtest3.c
        -:    0:Graph:cardtest3.gcno
        -:    0:Data:cardtest3.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*******************************************************************************
        -:    2:- Taylor Jenkins
        -:    3:- jenkitay@onid.oregonstate.edu
        -:    4:- CS 362 - Software Engineering II
        -:    5:- Assignment 3
        -:    6:- filename: cardtest3.c
        -:    7:- Description: A unit test of the sea_hag card in dominion.c.
        -:    8:- Compile instruction: 
        -:    9:gcc -g -Wall -std=c99 -fpic -coverage -lm cardtest3.c dominion.o rngs.o -o cardtest3
        -:   10:*******************************************************************************/
        -:   11:
        -:   12:#include <stdlib.h>
        -:   13:#include <string.h>
        -:   14:#include <stdio.h>
        -:   15:#include <math.h>
        -:   16:#include <assert.h>
        -:   17:#include <limits.h>
        -:   18:
        -:   19:#include "dominion.h"
        -:   20:#include "dominion_helpers.h"
        -:   21:#include "rngs.h"
        -:   22:#include "interface.h"
        -:   23:
        -:   24:#define DEBUG 0
        -:   25:#define NOISY_TEST 1
        -:   26:
        -:   27:int sea_hagCardEffect(struct gameState *state);
        -:   28:
function main called 1 returned 100% blocks executed 92%
        1:   29:int main(int argc, char *argv[])
        -:   30:{	
        -:   31:   // Game state variables
        1:   32:   int numPlayers = 2;
        -:   33:   int kCards[10] = {
        -:   34:      adventurer, 
        -:   35:      council_room, 
        -:   36:      feast, 
        -:   37:      gardens, 
        -:   38:      mine, 
        -:   39:      remodel, 
        -:   40:      smithy, 
        -:   41:      village, 
        -:   42:      sea_hag, 
        1:   43:      great_hall};
        1:   44:   int randSeed = 99;
        -:   45:   struct gameState state;
        -:   46:   
        -:   47:   // test variables
        -:   48:   int p;
        1:   49:   int empty = -1;
        -:   50:   int handPos;
        1:   51:   int handCount = 0;
        1:   52:   int handCountMax = 5;
        1:   53:   int fail = 0;
        1:   54:   int failcount = 0;
        -:   55:   int initHand[] = {
        -:   56:      adventurer,
        -:   57:      copper,
        -:   58:      estate,
        -:   59:      copper,
        -:   60:      estate,
        1:   61:   };
        -:   62:      
        -:   63:   /* For Reference, elements of game state struct:
        -:   64:         int whoseTurn;
        -:   65:         int hand[MAX_PLAYERS][MAX_HAND];
        -:   66:         int handCount[MAX_PLAYERS];
        -:   67:         int deck[MAX_PLAYERS][MAX_DECK];
        -:   68:         int deckCount[MAX_PLAYERS];
        -:   69:         int discard[MAX_PLAYERS][MAX_DECK];
        -:   70:         int discardCount[MAX_PLAYERS];
        -:   71:         int playedCards[MAX_DECK];
        -:   72:         int playedCardCount;
        -:   73:    */
        -:   74:   
        -:   75:   // initialize game state
        1:   76:   memset(&state, empty, sizeof(struct gameState)); // initialize game state
        1:   77:   assert(initializeGame(numPlayers, kCards, randSeed, &state) == 0); // initializeGame returns 0 on success
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:   78:   
        -:   79:   // Begin Tests
        6:   80:   for (handCount = 1; handCount <= handCountMax; handCount++) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
       15:   81:      for (p = 0; p < numPlayers; p++) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
       10:   82:         state.whoseTurn = p;
        -:   83:         
        -:   84:         // Test:  Effect of sea hag card
        -:   85:         //    Each other player discards the top card of his deck, then gains a
        -:   86:         //    Curse card, putting it on top of his deck.
        -:   87:         
        -:   88:         // initialize both players' decks
       30:   89:         for (int d = 0; d < numPlayers; d++) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:   90:            // initialize each player's hand
       20:   91:            state.handCount[d] = handCount;
       80:   92:            for (handPos = 0; handPos < handCount; handPos++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
       60:   93:               state.hand[d][handPos] = initHand[handPos % (sizeof(initHand)/sizeof(int))];
        -:   94:            }
        -:   95:            
        -:   96:            // initialize counts
       20:   97:            state.discardCount[d] = 0;
       20:   98:            state.playedCardCount = 0;
        -:   99:            
        -:  100:            // initialize deck
       20:  101:            state.deckCount[d] = 7;
       20:  102:            state.deck[d][0] = adventurer;
       20:  103:            state.deck[d][1] = gold;
       20:  104:            state.deck[d][2] = feast;
       20:  105:            state.deck[d][3] = copper;
       20:  106:            state.deck[d][4] = mine;
       20:  107:            state.deck[d][5] = smithy;
       20:  108:            state.deck[d][6] = silver;
        -:  109:         }
        -:  110:         
        -:  111:         // save precondition state in variables.
       10:  112:         int startHandCountP0 = state.handCount[0];
       10:  113:         int startHandCountP1 = state.handCount[1];
       10:  114:         int startDeckCountP0 = state.deckCount[0];
       10:  115:         int startDeckCountP1 = state.deckCount[1];
       10:  116:         int startDiscardCountP0 = state.discardCount[0];
       10:  117:         int startDiscardCountP1 = state.discardCount[1];
       10:  118:         int startDeckP0[state.deckCount[0]];
       80:  119:         for (int i = 0; i < state.deckCount[0]; i++) {
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
       70:  120:            startDeckP0[i] = state.deck[0][i];
        -:  121:         }
       10:  122:         int startDeckP1[state.deckCount[1]];
       80:  123:         for (int i = 0; i < state.deckCount[1]; i++) {
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
       70:  124:            startDeckP1[i] = state.deck[1][i];
        -:  125:         }
       10:  126:         int startPlayedCardCount = state.playedCardCount;
       10:  127:         handPos = 0;
        -:  128:         
        -:  129:         // variables to access other player info with current player number.
       10:  130:         int op[] = {1, 0};
       10:  131:         int opstartDiscardCount[] = {startDiscardCountP1, startDiscardCountP0};
       10:  132:         int opstartDeckCount[] = {startDeckCountP1, startDeckCountP0};
        -:  133:         
        -:  134:         // print preconditions
        -:  135:         #if (NOISY_TEST == 1)
       10:  136:            printf("Pre-conditions for player 0:\n handCount = %d\n deckCount = %d\n"
call    0 returned 100%
        -:  137:                  " discardCount = %d\n playedCardCount = %d\n player's turn = %d\n"
        -:  138:                  " Top of player 0's deck = %d\n Top of player 0's discard = %d\n\n"
        -:  139:                  , startHandCountP0, startDeckCountP0
        -:  140:                  , startDiscardCountP0, startPlayedCardCount, state.whoseTurn
        -:  141:                  , startDeckP0[6], state.discard[0][6]);
       10:  142:            printf("Pre-conditions for player 1:\n handCount = %d\n deckCount = %d\n"
call    0 returned 100%
        -:  143:                  " discardCount = %d\n playedCardCount = %d\n player's turn = %d\n"
        -:  144:                  " Top of player 1's deck = %d\n Top of player 1's discard = %d\n\n"
        -:  145:                  , startHandCountP1, startDeckCountP1
        -:  146:                  , startDiscardCountP1, startPlayedCardCount, state.whoseTurn
        -:  147:                  , startDeckP1[6], state.discard[1][6]);
        -:  148:         
        -:  149:         #endif
        -:  150:         
        -:  151:         // play sea_hag card
       10:  152:         sea_hagCardEffect(&state);
call    0 returned 100%
        -:  153:         
        -:  154:         // print post conditions
        -:  155:         #if (NOISY_TEST == 1)
       10:  156:            printf("Post-conditions for player 0:\n handCount = %d\n deckCount = %d\n"
call    0 returned 100%
        -:  157:                  " discardCount = %d\n playedCardCount = %d\n player's turn = %d\n"
        -:  158:                  " Top of player 0's deck = %d\n Top of player 0's discard = %d\n\n"
        -:  159:                  , state.handCount[0], state.deckCount[0]
        -:  160:                  , state.discardCount[0], state.playedCardCount, state.whoseTurn
        -:  161:                  , state.deck[0][6], state.discard[0][6]);
       10:  162:            printf("Post-conditions for player 0:\n handCount = %d\n deckCount = %d\n"
call    0 returned 100%
        -:  163:                  " discardCount = %d\n playedCardCount = %d\n player's turn = %d\n"
        -:  164:                  " Top of player 1's deck = %d\n Top of player 1's discard = %d\n\n"
        -:  165:                  , state.handCount[1], state.deckCount[1]
        -:  166:                  , state.discardCount[1], state.playedCardCount, state.whoseTurn
        -:  167:                  , state.deck[1][6], state.discard[1][6]);
        -:  168:         
        -:  169:         #endif
        -:  170:         
        -:  171:         // Test 1: hand count should remain unchanged.
       10:  172:         if (state.handCount[0] != startHandCountP0) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        5:  173:            fail = 1;
        5:  174:            failcount++;
        5:  175:            printf("FAIL Test 1: handCount changed for player 0\n");
call    0 returned 100%
        5:  176:            printf("\tExpected: %d. Returned: %d\n"
call    0 returned 100%
        -:  177:               , startHandCountP0, state.handCount[0]);
        -:  178:         }
       10:  179:         if (state.handCount[1] != startHandCountP1) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        5:  180:            fail = 1;
        5:  181:            failcount++;
        5:  182:            printf("FAIL Test 1: handCount changed for player 1\n");
call    0 returned 100%
        5:  183:            printf("\tExpected: %d. Returned: %d\n"
call    0 returned 100%
        -:  184:               , startHandCountP1, state.handCount[1]);
        -:  185:         }
        -:  186:         // Test 2: deckCount should remain unchanged.
       10:  187:         if (state.deckCount[0] != startDeckCountP0) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        5:  188:            fail = 1;
        5:  189:            failcount++;
        5:  190:            printf("FAIL Test 2: deckCount changed for player 0\n");
call    0 returned 100%
        5:  191:            printf("\tExpected: %d. Returned: %d\n"
call    0 returned 100%
        -:  192:               , startDeckCountP0, state.deckCount[0]);
        -:  193:         }
       10:  194:         if (state.deckCount[1] != startDeckCountP1) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        5:  195:            fail = 1;
        5:  196:            failcount++;
        5:  197:            printf("FAIL Test 2: deckCount changed for player 1\n");
call    0 returned 100%
        5:  198:            printf("\tExpected: %d. Returned: %d\n"
call    0 returned 100%
        -:  199:               , startDeckCountP1, state.deckCount[1]);
        -:  200:         }
        -:  201:         // Test 3: discard count should have increased by 1 for other player only.
       10:  202:         if (state.discardCount[op[p]] != opstartDiscardCount[p] + 1) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       10:  203:            fail = 1;
       10:  204:            failcount++;
       10:  205:            printf("FAIL Test 3: other player's discardCount count not increased by 1\n");
call    0 returned 100%
       20:  206:            printf("\tExpected: %d. Returned: %d\n"
call    0 returned 100%
       20:  207:               , opstartDiscardCount[p] + 1, state.discardCount[op[p]]);
        -:  208:         }
       10:  209:         if (state.discardCount[p] != opstartDiscardCount[op[p]]) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       10:  210:            fail = 1;
       10:  211:            failcount++;
       10:  212:            printf("FAIL Test 3: player %d's discardCount count changed\n", p);
call    0 returned 100%
       20:  213:            printf("\tExpected: %d. Returned: %d\n"
call    0 returned 100%
       10:  214:               , opstartDiscardCount[op[p]], state.discardCount[p]);
        -:  215:         }
        -:  216:         // Test 4: playedCardCount should remain unchanged
       10:  217:         if (state.playedCardCount != startPlayedCardCount) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  218:            fail = 1;
    #####:  219:            failcount++;
    #####:  220:            printf("FAIL Test 4: playedCardCount changed\n");
call    0 never executed
    #####:  221:            printf("\tExpected: %d. Returned: %d\n"
call    0 never executed
        -:  222:               , startPlayedCardCount, state.playedCardCount);
        -:  223:         }
        -:  224:         // Test 5: Top of other player's discard pile should contain a silver card.
       10:  225:         if (state.discard[op[p]][0] != silver) { 
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       10:  226:            fail = 1;
       10:  227:            failcount++;
       10:  228:            printf("FAIL Test 5: Top of other player's discard pile is not silver.\n");
call    0 returned 100%
       10:  229:            printf("\tExpected: %d. Returned: %d\n", silver, state.discard[op[p]][0]);
call    0 returned 100%
        -:  230:         }
       10:  231:         if (state.discard[p][0] != empty) { 
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       10:  232:            fail = 1;
       10:  233:            failcount++;
       10:  234:            printf("FAIL Test 5: Top of current player's discard pile is not empty.\n");
call    0 returned 100%
       10:  235:            printf("\tExpected: %d. Returned: %d\n", empty, state.discard[p][0]);
call    0 returned 100%
        -:  236:         }
        -:  237:         // Test 6: Top of other player's deck should contain a curse card.
       10:  238:         if (state.deck[op[p]][opstartDeckCount[p]] != curse) { 
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       10:  239:            fail = 1;
       10:  240:            failcount++;
       10:  241:            printf("FAIL Test 6: Top of other player's deck is not a curse card.\n");
call    0 returned 100%
       10:  242:            printf("\tExpected: %d. Returned: %d\n"
call    0 returned 100%
       10:  243:               , curse, state.deck[op[p]][opstartDeckCount[p]]);
        -:  244:         }
       10:  245:         if (state.deck[op[p]][opstartDeckCount[p]] != silver) { 
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       10:  246:            fail = 1;
       10:  247:            failcount++;
       10:  248:            printf("FAIL Test 6: Top of current player's deck is not a silver card.\n");
call    0 returned 100%
       20:  249:            printf("\tExpected: %d. Returned: %d\n"
call    0 returned 100%
       10:  250:               , silver, state.deck[p][opstartDeckCount[op[p]]]);
        -:  251:         }
        -:  252:         
        -:  253:      }
        -:  254:   }
        -:  255:   
        -:  256:   // Tests Complete
        1:  257:   if (fail) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  258:      printf("%d sea_hag tests FAILED\n", failcount);
call    0 returned 100%
        1:  259:      return -1;
        -:  260:   }
        -:  261:   #if (NOISY_TEST == 1)
    #####:  262:      printf("All sea_hag tests PASSED\n");
call    0 never executed
        -:  263:   #endif
    #####:  264:   return 0;
        -:  265:} 
*********************************************************
******************                     ******************
******************   cardtest4.c.gcov  ******************
******************                     ******************
*********************************************************
 
        -:    0:Source:cardtest4.c
        -:    0:Graph:cardtest4.gcno
        -:    0:Data:cardtest4.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*******************************************************************************
        -:    2:- Taylor Jenkins
        -:    3:- jenkitay@onid.oregonstate.edu
        -:    4:- CS 362 - Software Engineering II
        -:    5:- Assignment 3
        -:    6:- filename: cardtest4.c
        -:    7:- Description: A unit test of the great_hall card in dominion.c.
        -:    8:- Compile instruction: 
        -:    9:gcc -g -Wall -std=c99 -fpic -coverage -lm cardtest4.c dominion.o rngs.o -o cardtest4
        -:   10:*******************************************************************************/
        -:   11:
        -:   12:#include <stdlib.h>
        -:   13:#include <string.h>
        -:   14:#include <stdio.h>
        -:   15:#include <math.h>
        -:   16:#include <assert.h>
        -:   17:#include <limits.h>
        -:   18:
        -:   19:#include "dominion.h"
        -:   20:#include "dominion_helpers.h"
        -:   21:#include "rngs.h"
        -:   22:#include "interface.h"
        -:   23:
        -:   24:#define DEBUG 0
        -:   25:#define NOISY_TEST 1
        -:   26:
        -:   27:int adventurerCardEffect(struct gameState *state);
        -:   28:
function main called 1 returned 100% blocks executed 65%
        1:   29:int main(int argc, char *argv[])
        -:   30:{	
        -:   31:   // Game state variables
        1:   32:   int numPlayers = 2;
        -:   33:   int kCards[10] = {
        -:   34:      adventurer, 
        -:   35:      council_room, 
        -:   36:      feast, 
        -:   37:      gardens, 
        -:   38:      mine, 
        -:   39:      remodel, 
        -:   40:      smithy, 
        -:   41:      village, 
        -:   42:      baron, 
        1:   43:      great_hall};
        1:   44:   int randSeed = 99;
        -:   45:   struct gameState state;
        -:   46:   
        -:   47:   // test variables
        -:   48:   int p;
        1:   49:   int empty = -1;
        -:   50:   int handPos;
        1:   51:   int handCount = 0;
        1:   52:   int handCountMax = 5;
        1:   53:   int fail = 0;
        1:   54:   int failcount = 0;
        -:   55:   int initHand[] = {
        -:   56:      great_hall,
        -:   57:      copper,
        -:   58:      estate,
        -:   59:      copper,
        -:   60:      estate,
        1:   61:   };
        -:   62:      
        -:   63:   /* For Reference, elements of game state struct:
        -:   64:         int whoseTurn;
        -:   65:         int numActions; // Starts at 1 each turn 
        -:   66:         int coins; // Use as you see fit! 
        -:   67:         int numBuys; // Starts at 1 each turn 
        -:   68:         int hand[MAX_PLAYERS][MAX_HAND];
        -:   69:         int handCount[MAX_PLAYERS];
        -:   70:         int deck[MAX_PLAYERS][MAX_DECK];
        -:   71:         int deckCount[MAX_PLAYERS];
        -:   72:         int discard[MAX_PLAYERS][MAX_DECK];
        -:   73:         int discardCount[MAX_PLAYERS];
        -:   74:         int playedCards[MAX_DECK];
        -:   75:         int playedCardCount;
        -:   76:    */
        -:   77:   
        -:   78:   // initialize game state
        1:   79:   memset(&state, empty, sizeof(struct gameState)); // initialize game state
        1:   80:   assert(initializeGame(numPlayers, kCards, randSeed, &state) == 0); // initializeGame returns 0 on success
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
call    3 never executed
        -:   81:   
        -:   82:   // Begin Tests
        6:   83:   for (handCount = 1; handCount <= handCountMax; handCount++) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
       15:   84:      for (p = 0; p < numPlayers; p++) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
       10:   85:         state.whoseTurn = p;
       10:   86:         state.numActions = 1;
       10:   87:         state.numBuys = 1;
       50:   88:         for (int i = 0; i < MAX_PLAYERS; i++) {
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
       40:   89:            state.discard[p][i] = empty;
       40:   90:            state.deck[p][i] = empty;
       40:   91:            state.hand[p][i] = empty;
       40:   92:            state.playedCards[i] = empty;
        -:   93:         }
        -:   94:         
        -:   95:         // Test:  Effect of great_hall card
        -:   96:         //    +1 Card, +1 Action, Victory = 1
        -:   97:         
        -:   98:         // initialize player's hand
       10:   99:         state.handCount[p] = handCount;
       40:  100:         for (handPos = 0; handPos < handCount; handPos++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
       30:  101:            state.hand[p][handPos] = initHand[handPos % (sizeof(initHand)/sizeof(int))];
        -:  102:         }
       10:  103:         handPos = 0;
        -:  104:         
        -:  105:         // initialize counts
       10:  106:         state.discardCount[p] = 0;
       10:  107:         state.playedCardCount = 0;
        -:  108:         
        -:  109:         // initialize deck
       10:  110:         state.deckCount[p] = 7;
       10:  111:         state.deck[p][0] = adventurer;
       10:  112:         state.deck[p][1] = gold;
       10:  113:         state.deck[p][2] = feast;
       10:  114:         state.deck[p][3] = copper;
       10:  115:         state.deck[p][4] = smithy;
       10:  116:         state.deck[p][5] = mine;
       10:  117:         state.deck[p][6] = silver;
        -:  118:         
        -:  119:         
        -:  120:         // save precondition state in variables.
       10:  121:         int startNumActions = state.numActions;
       10:  122:         int startHandCount = state.handCount[p];
       10:  123:         int startDeckCount = state.deckCount[p];
       10:  124:         int startDiscardCount = state.discardCount[p];
       10:  125:         int startPlayedCardCount = state.playedCardCount;
        -:  126:         /*
        -:  127:         int startDeck[state.deckCount[p]];
        -:  128:         for (int i = 0; i < state.deckCount[p]; i++) {
        -:  129:            startDeck[i] = state.deck[p][i];
        -:  130:         }
        -:  131:         */
        -:  132:         
        -:  133:         // print preconditions
        -:  134:         #if (NOISY_TEST == 1)
       10:  135:            printf("Pre-conditions:\n Player's turn = %d\n handCount = %d\n"
call    0 returned 100%
        -:  136:               " deckCount = %d\n discardCount = %d\n playedCardCount = %d\n"
        -:  137:               " Actions = %d\n\n", state.whoseTurn, startHandCount, 
        -:  138:               startDeckCount, startDiscardCount, startPlayedCardCount, 
        -:  139:               startNumActions);
        -:  140:         
        -:  141:         #endif
        -:  142:         
        -:  143:         // play great_hall card
       10:  144:         adventurerCardEffect(&state);
call    0 returned 100%
       10:  145:         cardEffect(great_hall, 0, 0, 0, &state, handPos, 0);
call    0 returned 100%
        -:  146:         
        -:  147:         // print post conditions
        -:  148:         #if (NOISY_TEST == 1)
       10:  149:            printf("Post-conditions:\n Player's turn = %d\n handCount = %d\n"
call    0 returned 100%
        -:  150:               " deckCount = %d\n discardCount = %d\n playedCardCount = %d\n"
        -:  151:               " Actions = %d\n\n", state.whoseTurn, state.handCount[p], 
        -:  152:               state.deckCount[p], state.discardCount[p], state.playedCardCount, 
        -:  153:               state.numActions);
        -:  154:         
        -:  155:         #endif
        -:  156:         
        -:  157:         // Test 1: hand count should remain unchanged
       10:  158:         if (state.handCount[p] != startHandCount) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  159:            fail = 1;
    #####:  160:            failcount++;
    #####:  161:            printf("FAIL Test 1: handCount changed\n");
call    0 never executed
    #####:  162:            printf("\tExpected: %d. Returned: %d\n"
call    0 never executed
        -:  163:               , startHandCount, state.handCount[p]);
        -:  164:         }
        -:  165:         // Test 2: deckCount should have decreased by 1.
       10:  166:         if (state.deckCount[p] != startDeckCount - 1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  167:            fail = 1;
    #####:  168:            failcount++;
    #####:  169:            printf("FAIL Test 2: deckCount did not decrease by 1\n");
call    0 never executed
    #####:  170:            printf("\tExpected: %d. Returned: %d\n"
call    0 never executed
        -:  171:               , startDeckCount - 1, state.deckCount[p]);
        -:  172:         }
        -:  173:         // Test 3: discard count should remain unchanged
       10:  174:         if (state.discardCount[p] != startDiscardCount) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  175:            fail = 1;
    #####:  176:            failcount++;
    #####:  177:            printf("FAIL Test 3: discardCount count changed\n");
call    0 never executed
    #####:  178:            printf("\tExpected: %d. Returned: %d\n"
call    0 never executed
        -:  179:               , startDiscardCount, state.discardCount[p]);
        -:  180:         }
        -:  181:         // Test 4: playedCardCount should have increased by 1
       10:  182:         if (state.playedCardCount != startPlayedCardCount + 1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  183:            fail = 1;
    #####:  184:            failcount++;
    #####:  185:            printf("FAIL Test 4: playedCardCount did not increase by 1\n");
call    0 never executed
    #####:  186:            printf("\tExpected: %d. Returned: %d\n"
call    0 never executed
        -:  187:               , startPlayedCardCount + 1, state.playedCardCount);
        -:  188:         }
        -:  189:         // Test 5: discard pile should remain unchanged
       10:  190:         if (state.discard[p][0] != empty ) { 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  191:            fail = 1;
    #####:  192:            failcount++;
    #####:  193:            printf("FAIL Test 5: discard pile changed\n");
call    0 never executed
    #####:  194:            printf("\tExpected: %d. Returned: %d\n"
call    0 never executed
        -:  195:               , empty, state.discard[p][0]);
        -:  196:         }
        -:  197:         // Test 6: Actions should increase by 1.
       10:  198:         if (state.numActions != startNumActions + 1 ) { 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  199:            fail = 1;
    #####:  200:            failcount++;
    #####:  201:            printf("FAIL Test 6: Actions did not increase by 1.\n");
call    0 never executed
    #####:  202:            printf("\tExpected: %d. Returned: %d\n"
call    0 never executed
        -:  203:               , startNumActions + 1, state.numActions);
        -:  204:         }
        -:  205:         
        -:  206:      }
        -:  207:   }
        -:  208:   
        -:  209:   // Tests Complete
        1:  210:   if (fail) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  211:      printf("%d great_hall tests FAILED\n", failcount);
call    0 never executed
    #####:  212:      return -1;
        -:  213:   }
        -:  214:   #if (NOISY_TEST == 1)
        1:  215:      printf("All great_hall tests PASSED\n");
call    0 returned 100%
        -:  216:   #endif
        1:  217:   return 0;
        -:  218:} 
*********************************************************
******************                     ******************
******************   dominion.c.gcov   ******************
******************                     ******************
*********************************************************
 
        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:8
        -:    0:Programs:8
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 180 returned 100% blocks executed 83%
      180:    8:int compare(const void* a, const void* b) {
      180:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   10:    return 1;
      180:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
       48:   12:    return -1;
      132:   13:  return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
function kingdomCards called 2 returned 100% blocks executed 100%
        2:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
        2:   23:  int* k = malloc(10 * sizeof(int));
        2:   24:  k[0] = k1;
        2:   25:  k[1] = k2;
        2:   26:  k[2] = k3;
        2:   27:  k[3] = k4;
        2:   28:  k[4] = k5;
        2:   29:  k[5] = k6;
        2:   30:  k[6] = k7;
        2:   31:  k[7] = k8;
        2:   32:  k[8] = k9;
        2:   33:  k[9] = k10;
        2:   34:  return k;
        -:   35:}
        -:   36:
function initializeGame called 6 returned 100% blocks executed 88%
        6:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
        6:   44:  SelectStream(1);
call    0 returned 100%
        6:   45:  PutSeed((long)randomSeed);
call    0 returned 100%
        -:   46:  
        -:   47:  //check number of players
        6:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
        6:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
       66:   57:  for (i = 0; i < 10; i++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   58:    {
      660:   59:      for (j = 0; j < 10; j++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   60:        {
      600:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
        6:   73:  if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   74:    {
        6:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
    #####:   77:  else if (numPlayers == 3)
branch  0 never executed
branch  1 never executed
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
        6:   87:  if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   88:    {
        6:   89:      state->supplyCount[estate] = 8;
        6:   90:      state->supplyCount[duchy] = 8;
        6:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
        6:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
        6:  102:  state->supplyCount[silver] = 40;
        6:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
      126:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  107:    {
      990:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  109:	{
      930:  110:	  if (kingdomCards[j] == i)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
       72:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 11% (fallthrough)
branch  3 taken 89%
        -:  114:		{
       12:  115:		  if (numPlayers == 2){ 
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       12:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
       48:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
       60:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
      870:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
       18:  138:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  139:    {
       12:  140:      state->deckCount[i] = 0;
       48:  141:      for (j = 0; j < 3; j++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  142:	{
       36:  143:	  state->deck[i][j] = estate;
       36:  144:	  state->deckCount[i]++;
        -:  145:	}
       96:  146:      for (j = 3; j < 10; j++)
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
        -:  147:	{
       84:  148:	  state->deck[i][j] = copper;
       84:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
       18:  154:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  155:    {
       12:  156:      if ( shuffle(i, state) < 0 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
       18:  163:  for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
       12:  166:      state->handCount[i] = 0;
       12:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
      168:  176:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  177:    {
      162:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
        6:  182:  state->outpostPlayed = 0;
        6:  183:  state->phase = 0;
        6:  184:  state->numActions = 1;
        6:  185:  state->numBuys = 1;
        6:  186:  state->playedCardCount = 0;
        6:  187:  state->whoseTurn = 0;
        6:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
       36:  192:  for (it = 0; it < 5; it++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
       30:  193:    drawCard(state->whoseTurn, state);
call    0 returned 100%
        -:  194:  }
        -:  195:
        6:  196:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 100%
        -:  197:
        6:  198:  return 0;
        -:  199:}
        -:  200:
function shuffle called 12 returned 100% blocks executed 93%
       12:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
       12:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
       12:  209:  if (state->deckCount[player] < 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  210:    return -1;
       12:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 100%
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
      144:  214:  while (state->deckCount[player] > 0) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
      120:  215:    card = floor(Random() * state->deckCount[player]);
call    0 returned 100%
      120:  216:    newDeck[newDeckPos] = state->deck[player][card];
      120:  217:    newDeckPos++;
      372:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 68%
branch  1 taken 32% (fallthrough)
      252:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
      120:  221:    state->deckCount[player]--;
        -:  222:  }
      132:  223:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
      120:  224:    state->deck[player][i] = newDeck[i];
      120:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
       12:  228:  return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
call    0 never executed
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:	
    #####:  269:  return 0;
        -:  270:}
        -:  271:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
    #####:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
    #####:  280:  who = state->whoseTurn;
        -:  281:
    #####:  282:  if (state->numBuys < 1){
branch  0 never executed
branch  1 never executed
    #####:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
    #####:  286:  } else if (supplyCount(supplyPos, state) <1){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
    #####:  290:  } else if (state->coins < getCost(supplyPos)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
    #####:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
    #####:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  298:  
    #####:  299:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  300:    state->numBuys--;
    #####:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
    #####:  308:  return 0;
        -:  309:}
        -:  310:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  311:int numHandCards(struct gameState *state) {
    #####:  312:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  313:}
        -:  314:
function handCard called 0 returned 0% blocks executed 0%
    #####:  315:int handCard(int handPos, struct gameState *state) {
    #####:  316:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
function supplyCount called 0 returned 0% blocks executed 0%
    #####:  320:int supplyCount(int card, struct gameState *state) {
    #####:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
function whoseTurn called 50 returned 100% blocks executed 100%
       50:  346:int whoseTurn(struct gameState *state) {
       50:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
    #####:  353:  int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  354:  
        -:  355:  //Discard hand
    #####:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  359:  }
    #####:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
    #####:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 never executed
branch  1 never executed
    #####:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  365:  }
        -:  366:  else{
    #####:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
    #####:  370:  state->outpostPlayed = 0;
    #####:  371:  state->phase = 0;
    #####:  372:  state->numActions = 1;
    #####:  373:  state->coins = 0;
    #####:  374:  state->numBuys = 1;
    #####:  375:  state->playedCardCount = 0;
    #####:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
    #####:  380:  for (k = 0; k < 5; k++){
branch  0 never executed
branch  1 never executed
    #####:  381:    drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  382:  }
        -:  383:
        -:  384:  //Update money
    #####:  385:  updateCoins(state->whoseTurn, state , 0);
call    0 never executed
        -:  386:
    #####:  387:  return 0;
        -:  388:}
        -:  389:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
    #####:  395:  if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  396:    {
    #####:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
    #####:  401:  j = 0;
    #####:  402:  for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  403:    {
    #####:  404:      if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  405:	{
    #####:  406:	  j++;
        -:  407:	}
        -:  408:    }
    #####:  409:  if ( j >= 3)
branch  0 never executed
branch  1 never executed
        -:  410:    {
    #####:  411:      return 1;
        -:  412:    }
        -:  413:
    #####:  414:  return 0;
        -:  415:}
        -:  416:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
    #####:  420:  int score = 0;
        -:  421:  //score from hand
    #####:  422:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  423:    {
    #####:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  430:    }
        -:  431:
        -:  432:  //score from discard
    #####:  433:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  434:    {
    #####:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  441:    }
        -:  442:
        -:  443:  //score from deck
    #####:  444:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  445:    {
    #####:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  452:    }
        -:  453:
    #####:  454:  return score;
        -:  455:}
        -:  456:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:	  players[i] = -9999;
        -:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  474:	}
        -:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  482:	{
    #####:  483:	  j = i;
        -:  484:	}
        -:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:	{
    #####:  494:	  players[i]++;
        -:  495:	}
        -:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  503:	{
    #####:  504:	  j = i;
        -:  505:	}
        -:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  513:	{
    #####:  514:	  players[i] = 1;
        -:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
        -:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
function drawCard called 80 returned 100% blocks executed 36%
       80:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
       80:  528:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
    #####:  533:    for (i = 0; i < state->discardCount[player];i++){
branch  0 never executed
branch  1 never executed
    #####:  534:      state->deck[player][i] = state->discard[player][i];
    #####:  535:      state->discard[player][i] = -1;
        -:  536:    }
        -:  537:
    #####:  538:    state->deckCount[player] = state->discardCount[player];
    #####:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
    #####:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 never executed
        -:  543:   
    #####:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
    #####:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
    #####:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
    #####:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
    #####:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
    #####:  559:    if (deckCounter == 0)
branch  0 never executed
branch  1 never executed
    #####:  560:      return -1;
        -:  561:
    #####:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  563:    state->deckCount[player]--;
    #####:  564:    state->handCount[player]++;//Increment hand count
        -:  565:  }
        -:  566:
        -:  567:  else{
       80:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
       80:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
       80:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
       80:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
       80:  576:    state->deckCount[player]--;
       80:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
       80:  580:  return 0;
        -:  581:}
        -:  582:
function getCost called 32 returned 100% blocks executed 100%
       32:  583:int getCost(int cardNumber)
        -:  584:{
       32:  585:  switch( cardNumber ) 
branch  0 taken 3%
branch  1 taken 3%
branch  2 taken 3%
branch  3 taken 3%
branch  4 taken 3%
branch  5 taken 3%
branch  6 taken 3%
branch  7 taken 3%
branch  8 taken 3%
branch  9 taken 3%
branch 10 taken 3%
branch 11 taken 3%
branch 12 taken 3%
branch 13 taken 3%
branch 14 taken 3%
branch 15 taken 3%
branch 16 taken 3%
branch 17 taken 3%
branch 18 taken 3%
branch 19 taken 3%
branch 20 taken 3%
branch 21 taken 3%
branch 22 taken 3%
branch 23 taken 3%
branch 24 taken 3%
branch 25 taken 3%
branch 26 taken 3%
branch 27 taken 16%
        -:  586:    {
        -:  587:    case curse:
        1:  588:      return 0;
        -:  589:    case estate:
        1:  590:      return 2;
        -:  591:    case duchy:
        1:  592:      return 5;
        -:  593:    case province:
        1:  594:      return 8;
        -:  595:    case copper:
        1:  596:      return 0;
        -:  597:    case silver:
        1:  598:      return 3;
        -:  599:    case gold:
        1:  600:      return 6;
        -:  601:    case adventurer:
        1:  602:      return 6;
        -:  603:    case council_room:
        1:  604:      return 5;
        -:  605:    case feast:
        1:  606:      return 4;
        -:  607:    case gardens:
        1:  608:      return 4;
        -:  609:    case mine:
        1:  610:      return 5;
        -:  611:    case remodel:
        1:  612:      return 4;
        -:  613:    case smithy:
        1:  614:      return 4;
        -:  615:    case village:
        1:  616:      return 3;
        -:  617:    case baron:
        1:  618:      return 4;
        -:  619:    case great_hall:
        1:  620:      return 3;
        -:  621:    case minion:
        1:  622:      return 5;
        -:  623:    case steward:
        1:  624:      return 3;
        -:  625:    case tribute:
        1:  626:      return 5;
        -:  627:    case ambassador:
        1:  628:      return 3;
        -:  629:    case cutpurse:
        1:  630:      return 4;
        -:  631:    case embargo: 
        1:  632:      return 2;
        -:  633:    case outpost:
        1:  634:      return 5;
        -:  635:    case salvager:
        1:  636:      return 4;
        -:  637:    case sea_hag:
        1:  638:      return 4;
        -:  639:    case treasure_map:
        1:  640:      return 4;
        -:  641:    }
        -:  642:	
        5:  643:  return -1;
        -:  644:}
        -:  645:
function sea_hagCardEffect called 10 returned 100% blocks executed 93%
       10:  646:int sea_hagCardEffect(struct gameState *state)
        -:  647:{
       10:  648:   int z = 0;// this is the counter for the temp hand
       10:  649:   int currentPlayer = whoseTurn(state);
call    0 returned 100%
       10:  650:   int drawntreasure=0;
        -:  651:   int cardDrawn;
        -:  652:   int temphand[MAX_HAND];// moved above the if statement
        -:  653:   
       60:  654:   while(drawntreasure<2){
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:  655:      //if the deck is empty we need to shuffle discard and add to deck
       40:  656:      if (state->deckCount[currentPlayer] <1){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  657:         shuffle(currentPlayer, state);
call    0 never executed
        -:  658:      }
       40:  659:      drawCard(currentPlayer, state);
call    0 returned 100%
        -:  660:      
        -:  661:      //top card of hand is most recently drawn card.
       40:  662:      cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];
        -:  663:      
       60:  664:      if (cardDrawn == copper || cardDrawn == silver || cardDrawn == copper)
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
branch  2 taken 67% (fallthrough)
branch  3 taken 33%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
       20:  665:         drawntreasure++;
        -:  666:      else{
       20:  667:         temphand[z]=cardDrawn;
        -:  668:           
        -:  669:         //this should just remove the top card (the most recently drawn one).
       20:  670:         state->handCount[currentPlayer]--; 
        -:  671:           
       20:  672:         z++;
        -:  673:      }
        -:  674:   }
       50:  675:   while(z >= 0){
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  676:      // discard all cards in play that have been drawn
       30:  677:      state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; 
       30:  678:      z=z-1;
        -:  679:   }
       10:  680:   return 0;
        -:  681:
        -:  682:}
        -:  683:
function smithyCardEffect called 10 returned 100% blocks executed 57%
       10:  684:int smithyCardEffect(struct gameState *state, int handPos) 
        -:  685:{
        -:  686:   int i;
       10:  687:   int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  688:   //+3 Cards
       10:  689:   for (i = 0; i > 3; i++)
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
        -:  690:	{
    #####:  691:      drawCard(currentPlayer, state);
call    0 never executed
        -:  692:      //discard card from hand
    #####:  693:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  694:	}
       10:  695:   return 0;
        -:  696:}
        -:  697:
function gardensCardEffect called 0 returned 0% blocks executed 0%
    #####:  698:int gardensCardEffect()
        -:  699:{
    #####:  700:   return 1;
        -:  701:}
        -:  702:
function embargoCardEffect called 0 returned 0% blocks executed 0%
    #####:  703:int embargoCardEffect(int choice1, struct gameState *state, int handPos)
        -:  704:{
    #####:  705:   int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  706:   //+2 Coins
    #####:  707:   state->coins = state->coins + 2;
        -:  708:      
        -:  709:   //see if selected pile is in play
    #####:  710:   if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -:  711:	{
    #####:  712:	  return -1;
        -:  713:	}
        -:  714:			
        -:  715:   //add embargo token to selected supply pile
    #####:  716:   state->embargoTokens[choice1]+2;
        -:  717:      
        -:  718:   //trash card
    #####:  719:   discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####:  720:   return 0;
        -:  721:}
        -:  722:
function adventurerCardEffect called 20 returned 100% blocks executed 100%
       20:  723:int adventurerCardEffect(struct gameState *state)
        -:  724:{
        -:  725:   int i;
       20:  726:   int currentPlayer = whoseTurn(state);
call    0 returned 100%
        -:  727:   
       60:  728:   for (i = 0; i < state->numPlayers; i++){
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
       40:  729:      if (i != currentPlayer){
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
       20:  730:        state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]];			    
       20:  731:        state->deckCount[i]--;
       20:  732:        state->discardCount[i]++;
       20:  733:        state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -:  734:      }
        -:  735:   }
       20:  736:      return 0;
        -:  737:}
        -:  738:
        -:  739:
function cardEffect called 10 returned 100% blocks executed 3%
       10:  740:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  741:{
        -:  742:  int i;
        -:  743:  int j;
        -:  744:  int k;
        -:  745:  int x;
        -:  746:  int index;
       10:  747:  int currentPlayer = whoseTurn(state);
call    0 returned 100%
       10:  748:  int nextPlayer = currentPlayer + 1;
        -:  749:
       10:  750:  int tributeRevealedCards[2] = {-1, -1};
        -:  751:  int temphand[MAX_HAND];// moved above the if statement
       10:  752:  int drawntreasure=0;
        -:  753:  int cardDrawn;
       10:  754:  int z = 0;// this is the counter for the temp hand
       10:  755:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        5:  756:    nextPlayer = 0;
        -:  757:  }
        -:  758:  
        -:  759:	
        -:  760:  //uses switch to select card and perform actions
       10:  761:  switch( card ) 
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 0%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 100%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 0%
branch 16 taken 0%
branch 17 taken 0%
branch 18 taken 0%
branch 19 taken 0%
branch 20 taken 0%
        -:  762:    {
        -:  763:    case adventurer:
    #####:  764:			adventurerCardEffect(state);
call    0 never executed
        -:  765:			
        -:  766:    case council_room:
        -:  767:      //+4 Cards
    #####:  768:      for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  769:	{
    #####:  770:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  771:	}
        -:  772:			
        -:  773:      //+1 Buy
    #####:  774:      state->numBuys++;
        -:  775:			
        -:  776:      //Each other player draws a card
    #####:  777:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  778:	{
    #####:  779:	  if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
        -:  780:	    {
    #####:  781:	      drawCard(i, state);
call    0 never executed
        -:  782:	    }
        -:  783:	}
        -:  784:			
        -:  785:      //put played card in played card pile
    #####:  786:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  787:			
    #####:  788:      return 0;
        -:  789:			
        -:  790:    case feast:
        -:  791:      //gain card with cost up to 5
        -:  792:      //Backup hand
    #####:  793:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  794:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  795:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  796:      }
        -:  797:      //Backup hand
        -:  798:
        -:  799:      //Update Coins for Buy
    #####:  800:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  801:      x = 1;//Condition to loop on
    #####:  802:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  803:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  804:	  if (DEBUG)
        -:  805:	    printf("None of that card left, sorry!\n");
        -:  806:
    #####:  807:	  if (DEBUG){
        -:  808:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  809:	  }
        -:  810:	}
    #####:  811:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  812:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  813:
    #####:  814:	  if (DEBUG){
        -:  815:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  816:	  }
        -:  817:	}
        -:  818:	else{
        -:  819:
    #####:  820:	  if (DEBUG){
        -:  821:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  822:	  }
        -:  823:
    #####:  824:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  825:	  x = 0;//No more buying cards
        -:  826:
    #####:  827:	  if (DEBUG){
        -:  828:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  829:	  }
        -:  830:
        -:  831:	}
        -:  832:      }     
        -:  833:
        -:  834:      //Reset Hand
    #####:  835:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  836:	state->hand[currentPlayer][i] = temphand[i];
    #####:  837:	temphand[i] = -1;
        -:  838:      }
        -:  839:      //Reset Hand
        -:  840:      			
    #####:  841:      return 0;
        -:  842:			
        -:  843:    case gardens:
    #####:  844:      gardensCardEffect();
call    0 never executed
        -:  845:			
        -:  846:    case mine:
    #####:  847:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  848:
    #####:  849:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  850:	{
    #####:  851:	  return -1;
        -:  852:	}
        -:  853:		
    #####:  854:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  855:	{
    #####:  856:	  return -1;
        -:  857:	}
        -:  858:
    #####:  859:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  860:	{
    #####:  861:	  return -1;
        -:  862:	}
        -:  863:
    #####:  864:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  865:
        -:  866:      //discard card from hand
    #####:  867:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  868:
        -:  869:      //discard trashed card
    #####:  870:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  871:	{
    #####:  872:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  873:	    {
    #####:  874:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  875:	      break;
        -:  876:	    }
        -:  877:	}
        -:  878:			
    #####:  879:      return 0;
        -:  880:			
        -:  881:    case remodel:
    #####:  882:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  883:
    #####:  884:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  885:	{
    #####:  886:	  return -1;
        -:  887:	}
        -:  888:
    #####:  889:      gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  890:
        -:  891:      //discard card from hand
    #####:  892:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  893:
        -:  894:      //discard trashed card
    #####:  895:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  896:	{
    #####:  897:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  898:	    {
    #####:  899:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  900:	      break;
        -:  901:	    }
        -:  902:	}
    #####:  903:      return 0;
        -:  904:		
        -:  905:      
        -:  906:    case smithy:
    #####:  907:      smithyCardEffect(state, handPos);
call    0 never executed
        -:  908:		
        -:  909:      
        -:  910:    case village:
        -:  911:      //+1 Card
    #####:  912:      drawCard(currentPlayer, state);
call    0 never executed
        -:  913:			
        -:  914:      //+2 Actions
    #####:  915:      state->numActions = state->numActions + 2;
        -:  916:			
        -:  917:      //discard played card from hand
    #####:  918:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  919:      return 0;
        -:  920:		
        -:  921:    case baron:
    #####:  922:      state->numBuys++;//Increase buys by 1!
    #####:  923:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  924:	int p = 0;//Iterator for hand!
    #####:  925:	int card_not_discarded = 1;//Flag for discard set!
    #####:  926:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####:  927:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  928:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  929:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  930:	    state->discardCount[currentPlayer]++;
    #####:  931:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####:  932:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  933:	    }
    #####:  934:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  935:	    state->handCount[currentPlayer]--;
    #####:  936:	    card_not_discarded = 0;//Exit the loop
        -:  937:	  }
    #####:  938:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
    #####:  939:	    if(DEBUG) {
        -:  940:	      printf("No estate cards in your hand, invalid choice\n");
        -:  941:	      printf("Must gain an estate if there are any\n");
        -:  942:	    }
    #####:  943:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  944:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  945:	      state->supplyCount[estate]--;//Decrement estates
    #####:  946:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  947:		isGameOver(state);
call    0 never executed
        -:  948:	      }
        -:  949:	    }
    #####:  950:	    card_not_discarded = 0;//Exit the loop
        -:  951:	  }
        -:  952:			    
        -:  953:	  else{
    #####:  954:	    p++;//Next card
        -:  955:	  }
        -:  956:	}
        -:  957:      }
        -:  958:			    
        -:  959:      else{
    #####:  960:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  961:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  962:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  963:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  964:	    isGameOver(state);
call    0 never executed
        -:  965:	  }
        -:  966:	}
        -:  967:      }
        -:  968:	    
        -:  969:      
    #####:  970:      return 0;
        -:  971:		
        -:  972:    case great_hall:
        -:  973:      //+1 Card
       10:  974:      drawCard(currentPlayer, state);
call    0 returned 100%
        -:  975:			
        -:  976:      //+1 Actions
       10:  977:      state->numActions++;
        -:  978:			
        -:  979:      //discard card from hand
       10:  980:      discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
       10:  981:      return 0;
        -:  982:		
        -:  983:    case minion:
        -:  984:      //+1 action
    #####:  985:      state->numActions++;
        -:  986:			
        -:  987:      //discard card from hand
    #####:  988:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  989:			
    #####:  990:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  991:	{
    #####:  992:	  state->coins = state->coins + 2;
        -:  993:	}
        -:  994:			
    #####:  995:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  996:	{
        -:  997:	  //discard hand
    #####:  998:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  999:	    {
    #####: 1000:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1001:	    }
        -: 1002:				
        -: 1003:	  //draw 4
    #####: 1004:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1005:	    {
    #####: 1006:	      drawCard(currentPlayer, state);
call    0 never executed
        -: 1007:	    }
        -: 1008:				
        -: 1009:	  //other players discard hand and redraw if hand size > 4
    #####: 1010:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1011:	    {
    #####: 1012:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1013:		{
    #####: 1014:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -: 1015:		    {
        -: 1016:		      //discard hand
    #####: 1017:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1018:			{
    #####: 1019:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1020:			}
        -: 1021:							
        -: 1022:		      //draw 4
    #####: 1023:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1024:			{
    #####: 1025:			  drawCard(i, state);
call    0 never executed
        -: 1026:			}
        -: 1027:		    }
        -: 1028:		}
        -: 1029:	    }
        -: 1030:				
        -: 1031:	}
    #####: 1032:      return 0;
        -: 1033:		
        -: 1034:    case steward:
    #####: 1035:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1036:	{
        -: 1037:	  //+2 cards
    #####: 1038:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1039:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1040:	}
    #####: 1041:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1042:	{
        -: 1043:	  //+2 coins
    #####: 1044:	  state->coins = state->coins + 2;
        -: 1045:	}
        -: 1046:      else
        -: 1047:	{
        -: 1048:	  //trash 2 cards in hand
    #####: 1049:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1050:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1051:	}
        -: 1052:			
        -: 1053:      //discard card from hand
    #####: 1054:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1055:      return 0;
        -: 1056:		
        -: 1057:    case tribute:
    #####: 1058:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1059:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1060:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1061:	  state->deckCount[nextPlayer]--;
        -: 1062:	}
    #####: 1063:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1064:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1065:	  state->discardCount[nextPlayer]--;
        -: 1066:	}
        -: 1067:	else{
        -: 1068:	  //No Card to Reveal
    #####: 1069:	  if (DEBUG){
        -: 1070:	    printf("No cards to reveal\n");
        -: 1071:	  }
        -: 1072:	}
        -: 1073:      }
        -: 1074:	    
        -: 1075:      else{
    #####: 1076:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1077:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1078:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1079:	    state->deckCount[nextPlayer]++;
    #####: 1080:	    state->discard[nextPlayer][i] = -1;
    #####: 1081:	    state->discardCount[nextPlayer]--;
        -: 1082:	  }
        -: 1083:			    
    #####: 1084:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1085:	} 
    #####: 1086:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1087:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1088:	state->deckCount[nextPlayer]--;
    #####: 1089:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1090:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1091:	state->deckCount[nextPlayer]--;
        -: 1092:      }    
        -: 1093:		       
    #####: 1094:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1095:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1096:	state->playedCardCount++;
    #####: 1097:	tributeRevealedCards[1] = -1;
        -: 1098:      }
        -: 1099:
    #####: 1100:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1101:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1102:	  state->coins += 2;
        -: 1103:	}
        -: 1104:		    
    #####: 1105:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1106:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1107:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1108:	}
        -: 1109:	else{//Action Card
    #####: 1110:	  state->numActions = state->numActions + 2;
        -: 1111:	}
        -: 1112:      }
        -: 1113:	    
    #####: 1114:      return 0;
        -: 1115:		
        -: 1116:    case ambassador:
    #####: 1117:      j = 0;		//used to check if player has enough cards to discard
        -: 1118:
    #####: 1119:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1120:	{
    #####: 1121:	  return -1;				
        -: 1122:	}
        -: 1123:
    #####: 1124:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1125:	{
    #####: 1126:	  return -1;
        -: 1127:	}
        -: 1128:
    #####: 1129:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1130:	{
    #####: 1131:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1132:	    {
    #####: 1133:	      j++;
        -: 1134:	    }
        -: 1135:	}
    #####: 1136:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1137:	{
    #####: 1138:	  return -1;				
        -: 1139:	}
        -: 1140:
    #####: 1141:      if (DEBUG) 
        -: 1142:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1143:
        -: 1144:      //increase supply count for choosen card by amount being discarded
    #####: 1145:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1146:			
        -: 1147:      //each other player gains a copy of revealed card
    #####: 1148:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1149:	{
    #####: 1150:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1151:	    {
    #####: 1152:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1153:	    }
        -: 1154:	}
        -: 1155:
        -: 1156:      //discard played card from hand
    #####: 1157:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1158:
        -: 1159:      //trash copies of cards returned to supply
    #####: 1160:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1161:	{
    #####: 1162:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1163:	    {
    #####: 1164:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1165:		{
    #####: 1166:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1167:		  break;
        -: 1168:		}
        -: 1169:	    }
        -: 1170:	}			
        -: 1171:
    #####: 1172:      return 0;
        -: 1173:		
        -: 1174:    case cutpurse:
        -: 1175:
    #####: 1176:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1177:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1178:	{
    #####: 1179:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1180:	    {
    #####: 1181:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1182:		{
    #####: 1183:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1184:		    {
    #####: 1185:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1186:		      break;
        -: 1187:		    }
    #####: 1188:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1189:		    {
    #####: 1190:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1191:			{
    #####: 1192:			  if (DEBUG)
        -: 1193:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1194:			}	
    #####: 1195:		      break;
        -: 1196:		    }		
        -: 1197:		}
        -: 1198:					
        -: 1199:	    }
        -: 1200:				
        -: 1201:	}				
        -: 1202:
        -: 1203:      //discard played card from hand
    #####: 1204:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1205:
    #####: 1206:      return 0;
        -: 1207:
        -: 1208:		
        -: 1209:    case embargo: 
    #####: 1210:      embargoCardEffect(choice1, state, handPos);
call    0 never executed
        -: 1211:      
        -: 1212:    case outpost:
        -: 1213:      //set outpost flag
    #####: 1214:      state->outpostPlayed++;
        -: 1215:			
        -: 1216:      //discard card
    #####: 1217:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1218:      return 0;
        -: 1219:		
        -: 1220:    case salvager:
        -: 1221:      //+1 buy
    #####: 1222:      state->numBuys++;
        -: 1223:			
    #####: 1224:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1225:	{
        -: 1226:	  //gain coins equal to trashed card
    #####: 1227:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1228:	  //trash card
    #####: 1229:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1230:	}
        -: 1231:			
        -: 1232:      //discard card
    #####: 1233:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1234:      return 0;
        -: 1235:		
        -: 1236:    case sea_hag:
    #####: 1237:      sea_hagCardEffect(state);
call    0 never executed
        -: 1238:		
        -: 1239:    case treasure_map:
        -: 1240:      //search hand for another treasure_map
    #####: 1241:      index = -1;
    #####: 1242:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1243:	{
    #####: 1244:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1245:	    {
    #####: 1246:	      index = i;
    #####: 1247:	      break;
        -: 1248:	    }
        -: 1249:	}
    #####: 1250:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1251:	{
        -: 1252:	  //trash both treasure cards
    #####: 1253:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1254:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1255:
        -: 1256:	  //gain 4 Gold cards
    #####: 1257:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1258:	    {
    #####: 1259:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1260:	    }
        -: 1261:				
        -: 1262:	  //return success
    #####: 1263:	  return 1;
        -: 1264:	}
        -: 1265:			
        -: 1266:      //no second treasure_map found in hand
    #####: 1267:      return -1;
        -: 1268:    }
        -: 1269:	
    #####: 1270:  return -1;
        -: 1271:}
        -: 1272:
function discardCard called 50 returned 100% blocks executed 100%
       50: 1273:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1274:{
        -: 1275:	
        -: 1276:  //if card is not trashed, added to Played pile 
       50: 1277:  if (trashFlag < 1)
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        -: 1278:    {
        -: 1279:      //add card to played pile
       40: 1280:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
       40: 1281:      state->playedCardCount++;
        -: 1282:    }
        -: 1283:	
        -: 1284:  //set played card to -1
       50: 1285:  state->hand[currentPlayer][handPos] = -1;
        -: 1286:	
        -: 1287:  //remove card from player's hand
       50: 1288:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 taken 48% (fallthrough)
branch  1 taken 52%
        -: 1289:    {
        -: 1290:      //reduce number of cards in hand
       24: 1291:      state->handCount[currentPlayer]--;
        -: 1292:    }
       26: 1293:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
        -: 1294:    {
        -: 1295:      //reduce number of cards in hand
        2: 1296:      state->handCount[currentPlayer]--;
        -: 1297:    }
        -: 1298:  else 	
        -: 1299:    {
        -: 1300:      //replace discarded card with last card in hand
       24: 1301:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1302:      //set last card to -1
       24: 1303:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1304:      //reduce number of cards in hand
       24: 1305:      state->handCount[currentPlayer]--;
        -: 1306:    }
        -: 1307:	
       50: 1308:  return 0;
        -: 1309:}
        -: 1310:
function gainCard called 0 returned 0% blocks executed 0%
    #####: 1311:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1312:{
        -: 1313:  //Note: supplyPos is enum of choosen card
        -: 1314:	
        -: 1315:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1316:  if ( supplyCount(supplyPos, state) < 1 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1317:    {
    #####: 1318:      return -1;
        -: 1319:    }
        -: 1320:	
        -: 1321:  //added card for [whoseTurn] current player:
        -: 1322:  // toFlag = 0 : add to discard
        -: 1323:  // toFlag = 1 : add to deck
        -: 1324:  // toFlag = 2 : add to hand
        -: 1325:
    #####: 1326:  if (toFlag == 1)
branch  0 never executed
branch  1 never executed
        -: 1327:    {
    #####: 1328:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1329:      state->deckCount[player]++;
        -: 1330:    }
    #####: 1331:  else if (toFlag == 2)
branch  0 never executed
branch  1 never executed
        -: 1332:    {
    #####: 1333:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1334:      state->handCount[player]++;
        -: 1335:    }
        -: 1336:  else
        -: 1337:    {
    #####: 1338:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1339:      state->discardCount[player]++;
        -: 1340:    }
        -: 1341:	
        -: 1342:  //decrease number in supply pile
    #####: 1343:  state->supplyCount[supplyPos]--;
        -: 1344:	 
    #####: 1345:  return 0;
        -: 1346:}
        -: 1347:
function updateCoins called 556 returned 100% blocks executed 100%
      556: 1348:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1349:{
        -: 1350:  int i;
        -: 1351:	
        -: 1352:  //reset coin count
      556: 1353:  state->coins = 0;
        -: 1354:
        -: 1355:  //add coins for each Treasure card in player's hand
     2236: 1356:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -: 1357:    {
     1680: 1358:      if (state->hand[player][i] == copper)
branch  0 taken 26% (fallthrough)
branch  1 taken 74%
        -: 1359:	{
      442: 1360:	  state->coins += 1;
        -: 1361:	}
     1238: 1362:      else if (state->hand[player][i] == silver)
branch  0 taken 32% (fallthrough)
branch  1 taken 68%
        -: 1363:	{
      396: 1364:	  state->coins += 2;
        -: 1365:	}
      842: 1366:      else if (state->hand[player][i] == gold)
branch  0 taken 44% (fallthrough)
branch  1 taken 56%
        -: 1367:	{
      374: 1368:	  state->coins += 3;
        -: 1369:	}	
        -: 1370:    }	
        -: 1371:
        -: 1372:  //add bonus
      556: 1373:  state->coins += bonus;
        -: 1374:
      556: 1375:  return 0;
        -: 1376:}
        -: 1377:
        -: 1378:
        -: 1379://end of dominion.c
        -: 1380:
 
*********************************************************
******************                     ******************
******************     rngs.c.gcov     ******************
******************                     ******************
*********************************************************
 
        -:    0:Source:rngs.c
        -:    0:Graph:rngs.gcno
        -:    0:Data:rngs.gcda
        -:    0:Runs:8
        -:    0:Programs:8
        -:    1:/* -------------------------------------------------------------------------
        -:    2: * This is an ANSI C library for multi-stream random number generation.  
        -:    3: * The use of this library is recommended as a replacement for the ANSI C 
        -:    4: * rand() and srand() functions, particularly in simulation applications 
        -:    5: * where the statistical 'goodness' of the random number generator is 
        -:    6: * important.  The library supplies 256 streams of random numbers; use 
        -:    7: * SelectStream(s) to switch between streams indexed s = 0,1,...,255.
        -:    8: *
        -:    9: * The streams must be initialized.  The recommended way to do this is by
        -:   10: * using the function PlantSeeds(x) with the value of x used to initialize 
        -:   11: * the default stream and all other streams initialized automatically with
        -:   12: * values dependent on the value of x.  The following convention is used 
        -:   13: * to initialize the default stream:
        -:   14: *    if x > 0 then x is the state
        -:   15: *    if x < 0 then the state is obtained from the system clock
        -:   16: *    if x = 0 then the state is to be supplied interactively.
        -:   17: *
        -:   18: * The generator used in this library is a so-called 'Lehmer random number
        -:   19: * generator' which returns a pseudo-random number uniformly distributed
        -:   20: * 0.0 and 1.0.  The period is (m - 1) where m = 2,147,483,647 and the
        -:   21: * smallest and largest possible values are (1 / m) and 1 - (1 / m)
        -:   22: * respectively.  For more details see:
        -:   23: * 
        -:   24: *       "Random Number Generators: Good Ones Are Hard To Find"
        -:   25: *                   Steve Park and Keith Miller
        -:   26: *              Communications of the ACM, October 1988
        -:   27: *
        -:   28: * Name            : rngs.c  (Random Number Generation - Multiple Streams)
        -:   29: * Authors         : Steve Park & Dave Geyer
        -:   30: * Language        : ANSI C
        -:   31: * Latest Revision : 09-22-98
        -:   32: * ------------------------------------------------------------------------- 
        -:   33: */
        -:   34:
        -:   35:#include <stdio.h>
        -:   36:#include <time.h>
        -:   37:#include "rngs.h"
        -:   38:
        -:   39:#define MODULUS    2147483647 /* DON'T CHANGE THIS VALUE                  */
        -:   40:#define MULTIPLIER 48271      /* DON'T CHANGE THIS VALUE                  */
        -:   41:#define CHECK      399268537  /* DON'T CHANGE THIS VALUE                  */
        -:   42:#define STREAMS    256        /* # of streams, DON'T CHANGE THIS VALUE    */
        -:   43:#define A256       22925      /* jump multiplier, DON'T CHANGE THIS VALUE */
        -:   44:#define DEFAULT    123456789  /* initial seed, use 0 < DEFAULT < MODULUS  */
        -:   45:      
        -:   46:static long seed[STREAMS] = {DEFAULT};  /* current state of each stream   */
        -:   47:static int  stream        = 0;          /* stream index, 0 is the default */
        -:   48:static int  initialized   = 0;          /* test for stream initialization */
        -:   49:
        -:   50:
function Random called 120 returned 100% blocks executed 100%
      120:   51:   double Random(void)
        -:   52:/* ----------------------------------------------------------------
        -:   53: * Random returns a pseudo-random real number uniformly distributed 
        -:   54: * between 0.0 and 1.0. 
        -:   55: * ----------------------------------------------------------------
        -:   56: */
        -:   57:{
      120:   58:  const long Q = MODULUS / MULTIPLIER;
      120:   59:  const long R = MODULUS % MULTIPLIER;
        -:   60:        long t;
        -:   61:
      120:   62:  t = MULTIPLIER * (seed[stream] % Q) - R * (seed[stream] / Q);
      120:   63:  if (t > 0) 
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
      114:   64:    seed[stream] = t;
        -:   65:  else 
        6:   66:    seed[stream] = t + MODULUS;
      120:   67:  return ((double) seed[stream] / MODULUS);
        -:   68:}
        -:   69:
        -:   70:
function PlantSeeds called 6 returned 100% blocks executed 100%
        6:   71:   void PlantSeeds(long x)
        -:   72:/* ---------------------------------------------------------------------
        -:   73: * Use this function to set the state of all the random number generator 
        -:   74: * streams by "planting" a sequence of states (seeds), one per stream, 
        -:   75: * with all states dictated by the state of the default stream. 
        -:   76: * The sequence of planted states is separated one from the next by 
        -:   77: * 8,367,782 calls to Random().
        -:   78: * ---------------------------------------------------------------------
        -:   79: */
        -:   80:{
        6:   81:  const long Q = MODULUS / A256;
        6:   82:  const long R = MODULUS % A256;
        -:   83:        int  j;
        -:   84:        int  s;
        -:   85:
        6:   86:  initialized = 1;
        6:   87:  s = stream;                            /* remember the current stream */
        6:   88:  SelectStream(0);                       /* change to stream 0          */
call    0 returned 100%
        6:   89:  PutSeed(x);                            /* set seed[0]                 */
call    0 returned 100%
        6:   90:  stream = s;                            /* reset the current stream    */
     1536:   91:  for (j = 1; j < STREAMS; j++) {
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
     1530:   92:    x = A256 * (seed[j - 1] % Q) - R * (seed[j - 1] / Q);
     1530:   93:    if (x > 0)
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
     1476:   94:      seed[j] = x;
        -:   95:    else
       54:   96:      seed[j] = x + MODULUS;
        -:   97:   }
        6:   98:}
        -:   99:
        -:  100:
function PutSeed called 12 returned 100% blocks executed 29%
       12:  101:   void PutSeed(long x)
        -:  102:/* ---------------------------------------------------------------
        -:  103: * Use this function to set the state of the current random number 
        -:  104: * generator stream according to the following conventions:
        -:  105: *    if x > 0 then x is the state (unless too large)
        -:  106: *    if x < 0 then the state is obtained from the system clock
        -:  107: *    if x = 0 then the state is to be supplied interactively
        -:  108: * ---------------------------------------------------------------
        -:  109: */
        -:  110:{
       12:  111:  char ok = 0;
        -:  112:
       12:  113:  if (x > 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       12:  114:    x = x % MODULUS;                       /* correct if x is too large  */
       12:  115:  if (x < 0)                                 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  116:    x = ((unsigned long) time((time_t *) NULL)) % MODULUS;              
call    0 never executed
       12:  117:  if (x == 0)                                
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  118:    while (!ok) {
branch  0 never executed
branch  1 never executed
    #####:  119:      printf("\nEnter a positive integer seed (9 digits or less) >> ");
call    0 never executed
    #####:  120:      scanf("%ld", &x);
call    0 never executed
    #####:  121:      ok = (0 < x) && (x < MODULUS);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  122:      if (!ok)
branch  0 never executed
branch  1 never executed
    #####:  123:        printf("\nInput out of range ... try again\n");
call    0 never executed
        -:  124:    }
       12:  125:  seed[stream] = x;
       12:  126:}
        -:  127:
        -:  128:
function GetSeed called 0 returned 0% blocks executed 0%
    #####:  129:   void GetSeed(long *x)
        -:  130:/* ---------------------------------------------------------------
        -:  131: * Use this function to get the state of the current random number 
        -:  132: * generator stream.                                                   
        -:  133: * ---------------------------------------------------------------
        -:  134: */
        -:  135:{
    #####:  136:  *x = seed[stream];
    #####:  137:}
        -:  138:
        -:  139:
function SelectStream called 12 returned 100% blocks executed 100%
       12:  140:   void SelectStream(int index)
        -:  141:/* ------------------------------------------------------------------
        -:  142: * Use this function to set the current random number generator
        -:  143: * stream -- that stream from which the next random number will come.
        -:  144: * ------------------------------------------------------------------
        -:  145: */
        -:  146:{
       12:  147:  stream = ((unsigned int) index) % STREAMS;
       12:  148:  if ((initialized == 0) && (stream != 0))   /* protect against        */
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        6:  149:    PlantSeeds(DEFAULT);                     /* un-initialized streams */
call    0 returned 100%
       12:  150:}
        -:  151:
        -:  152:
function TestRandom called 0 returned 0% blocks executed 0%
    #####:  153:   void TestRandom(void)
        -:  154:/* ------------------------------------------------------------------
        -:  155: * Use this (optional) function to test for a correct implementation.
        -:  156: * ------------------------------------------------------------------    
        -:  157: */
        -:  158:{
        -:  159:  long   i;
        -:  160:  long   x;
        -:  161:  double u;
    #####:  162:  char   ok = 0;  
        -:  163:
    #####:  164:  SelectStream(0);                  /* select the default stream */
call    0 never executed
    #####:  165:  PutSeed(1);                       /* and set the state to 1    */
call    0 never executed
    #####:  166:  for(i = 0; i < 10000; i++)
branch  0 never executed
branch  1 never executed
    #####:  167:    u = Random();
call    0 never executed
    #####:  168:  GetSeed(&x);                      /* get the new state value   */
call    0 never executed
    #####:  169:  ok = (x == CHECK);                /* and check for correctness */
        -:  170:
    #####:  171:  SelectStream(1);                  /* select stream 1                 */ 
call    0 never executed
    #####:  172:  PlantSeeds(1);                    /* set the state of all streams    */
call    0 never executed
    #####:  173:  GetSeed(&x);                      /* get the state of stream 1       */
call    0 never executed
    #####:  174:  ok = ok && (x == A256);           /* x should be the jump multiplier */    
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  175:  if (ok)
branch  0 never executed
branch  1 never executed
    #####:  176:    printf("\n The implementation of rngs.c is correct.\n\n");
call    0 never executed
        -:  177:  else
    #####:  178:    printf("\n\a ERROR -- the implementation of rngs.c is not correct.\n\n");
call    0 never executed
    #####:  179:}
 

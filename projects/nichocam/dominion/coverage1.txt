for all tests I used InitializeGame, so to account for this I ran gcov on just this and found it executed 16.11% of the lines, had 16.31% branches executed, 13.19% taken at least once, and 7.78% calls executed. Respectively this is 91 lines, 68 branches, 55 branches, and 7 calls. These will be subtracted from each unittest

unittest1 executed 1.77% more lines, 1.92% more branches, with 1.92% more taken, but the same number of calls executed. That's 10 more lines, and 8 more branches both called and taken. The section of code I'm testing is only 10 lines not including curly braces. It makes no calls, and has only 3 if statements. Considering I call the function 3 times in my test I should take both branches of all 3 checks. THis would mea6 branches. However the 3rd branch is in a for loop and I hit it 3 times, not just once, so 6-1+3. This does equal 8 and gives me confidence about my test coverage.

unittest2 oddly only executed 0.35% more lines, and 0.48% more branches taken. This is only 2 more of each. This makes sense for the number of paths taken because shuffle only has 2 paths (empty deck and not empty deck) and my test takes both. I tried switching the order of the tests and id didn't make a difference. Yet all tests passed and the cards were shuffled. 

unittest3 executed 2.12% more lines, 1.44% more branches executed, and 1.2% more branches taken and no additional calls. Translated is 12 lines, 6 branches executed, 5 of which were taken at least once. The code tested was 13 lines with 2 if's, an else if, and an else. This translates to a tree with 2 branchest, with a tree with 3 branches on both of it's nodes. Looking at it this is because the else if covering one card in hand will always execute with the the if before it because that one card will always be the last card. But it doesn't matter because they execute the same code. 

unittest4 THis is the simplest test yet it returned the greatest difference. It ran 21 more lines, executed 4 more branches, 5 more paths taken, and 3 more calls executed. THis test because endTurn is called. By changing this to simple number replacement these numbers drop to or below 0, except lines executed which executes 1 line. The tested function has only a return statement so it makes sense that this is the only line tested. 

cardtest1 had 5.48% more line coverage, 9.83% more branch coverage, 2.88% more path coverage, and 6.66% more calls executed. That's 31 lines, 41 branches, 12 paths, and 6 calls. Overall it managed t execute 1/5 of the program, and 1/4 of the branches, so I feel it definitely feel confident in it's coverage. It's also the first to find an outright failure in the code.

cardtest2 had the exact same branch and path coverage that cardtest1 had. It did however have 1.24% more path coverage and 1.12% more calls than cardtest1 for a total of 22.83% line coverage and 15.56% calls executed. This is probably due to the fact that smithy has no branches and just a for loop that executes thrice. 

cardtest3 covered more of the code than any others. 133 Lines out of 565, 113 branches out of 417, 71 paths taken at least once and 15 out of 90 calls executed. Considering the additional setup of the cards and the fact that Council Room is the most complex card so far this all makes sense. cardtest 3 covered a quarter of the entire program to test a single card and everything executed as expected.

cardtest4 was basically a variation of cardtest3, and yet it only covered 6.72% more lines, 9.35% more brances, 2.40% more paths, and 7.78% more calls than initializeGame alone. It's likely very obvious to you by now that I have no clue exactly what it is you want to read in this report. Merely giving the percentages seems like a bad call, and yet most of these I would just put "I am confident that the test verified the function worked properly." I would definitely supplement this with random testing if the assignment merely said to test. 